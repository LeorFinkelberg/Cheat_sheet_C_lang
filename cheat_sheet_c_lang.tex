\documentclass[%
	11pt,
	a4paper,
	utf8,
	%twocolumn
		]{article}	

\usepackage{style_packages/podvoyskiy_article_extended}


\begin{document}
\title{Приемы программирования на языке C}

\author{}

\date{}
\maketitle

\thispagestyle{fancy}

\tableofcontents

\section{Ресуры по языку Cи}

\url{https://learnc.info/c/}

\section{Вводные замечания}

Язык Си -- это компилируемый язык программирования высокого уровня, кроссплатформенный, позволяющий создавать программы которые будут работать во всех операционных системах, но для каждой операционной системы компиляцию нужно выполнять отдельно. 

Существует несколько стандартов языка Си: C90 (ANSI C/ISO C), C99 и C11. Для того чтобы использовать правила конкретного стандарта, нужно в составе команды компиляции указать следующие флаги: \verb*|-std=c90|, \verb|-std=c99| или \verb*|-std=c11|. Современный язык Си включает возможности стандарта С11.

Узнать используемый стандарт языка Си внутри программы можно с помощью \emph{макроса} \verb|__STDC_VERSION__|
\begin{lstlisting}[
style = c_cpp,
numbers = none	
]
printf("%ld\n", __STDC_VERSION__); // 201112
\end{lstlisting}

Получить информацию о версии компилятора позволяет макрос \verb*|__VERSION__|
\begin{lstlisting}[
style = c_cpp,
numbers = none	
]
printf("%s\n", __VERSION__); // Apple LLVM 12.0.0 (clang-1200.0.32.2)
\end{lstlisting}

Когда мы в командной строке вводим название программы без предварительного указания пути к ней, то
\begin{itemize}
	\item вначале поиск программы выполняется в текущем рабочем каталоге (обычно это каталог, из которого запускается программа),
	
	\item а затем в путях, указанных в системной переменной \verb|PATH|.
\end{itemize}

Системные каталоги имеют более высокий приоритет, чем каталоги, указанные в переменной \verb*|PATH|.

\section{Установка MSYS2 и MinGW-W64 для ОС Windows}

Установить компилятор \verb|gcc| на ОС Windows можно следующим образом. Детали процедуры установки можно найти в книге \cite[\strbook{24}]{prokhorenok-prog-c:2020}. Предварительно нам нужно установить библиотеку MSYS2. Переходим на сайт \url{https://www.msys2.org} и скачиваем файл \verb*|msys2-x86_64-20230718.exe|, а затем запускаем его.

Библиотека MSYS2 будет установлена в каталог \directory{C > msys64}. В этом каталоге расположены скрипты для запуска: \verb|msys2.exe|, \verb*|mingw32.exe|, \verb|mingw64.exe|.

Файл \verb*|msys2.exe| запускает командную строку, в которой мы можем установить различные библиотеки. Сначала обновим программу, выполнив команду
\begin{lstlisting}[
title = {\sffamily Окно msys2.exe},
style = bash,
numbers = none
]
$ pacman -Syu
\end{lstlisting}

Теперь можно установить библиотеку MinGW-W64
\begin{lstlisting}[
style = bash,
numbers = none
]
$ pacman -S mingw-w64-x86_64-toolchain
\end{lstlisting}

Для установки всех компонентов нажимаем клавишу \verb*|<Enter>|, а затем на запрос подтверждения установки вводим букву \verb|Y| и нажимаем клавишу \verb|<Enter>|.

Библиотека MinGW-W64 будет установлена в каталог \directory{C > msys64 > mingw64}. Добавив путь до \directory{C > msys64 > mingw64 > bin} в системную переменную \verb*|Path|, можно будет вызывать компилятор \verb|gcc| из любой точки
\begin{lstlisting}[
style = bash,
numbers = none
]
$ gcc --version
g++.exe (Rev2, Built by MSYS2 project) 13.2.0
...
\end{lstlisting}

Все установленные библиотеки скомпилированы под 64-битные операционные системы. Для установки 32-битных версий библиотек нужно в команде заменить фрагмент \verb*|x86_64| фрагментом \verb|i686|. Пример
\begin{lstlisting}[
style = bash,
numbers = none
]
$ pacman -S mingw-w64-i686-toolchain
\end{lstlisting}

\section{Приемы работы в редакторе Eclipse}

\subsection{Настройка редактора Eclipse}

Чтобы сделать иконки панели покрупнее, следует добавить в файл \verb|eclipse.ini| следующие строки
\begin{lstlisting}[
title = {\sffamily \$HOME/eclipse/cpp-2023-06/eclipse/eclipse.ini},
style = bash,
numbers = none
]
-Dswt.enable.autoScale=true
-Dswt.autoScale=150
-Dswt.autoScale.method=nearest
\end{lstlisting}

Чтобы редактор поддерживал Vim, следует в меню \menu{Help > Eclipse Markertplace} в строке Find вбить <<Vrapper>> и затем следовать инструкциям по установке.

\subsection{Сборка и запуск проекта}

Для того чтобы преобразовать текстовый файл \verb|Test64c.c| с программой в исполняемый exe-файл, делаем текущей вкладку с содержимым файла \verb|Test64c.c| и в меню \verb|Project| выбираем пункт \verb|Build Project|. В результате компиляции в рабочем каталоге будет создан каталог \directory{Debug}. Внутри этого каталога находится файл \verb|Test64c.exe|, который можно запустить на выполнение с помощью двойного щелчка мыши на значке файла.

Для запуска делаем текущей вкладку с содержимым файла \verb|Test64c.c| и в меню \verb|Run| выбираем пункт \verb|Run|. В открывшемся окне выбираем пункт \verb|Local C/C++ Application| и нажимаем кнопку \verb|OK|. Результат выполнения программы отобразится в окне \verb|Console|.

Простейший пример программы
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
#include <stdio.h>

int main(void) {
    printf("Hello, world");
    
    // в main() ключевое слово return можно не указывать
    return 0;
}
\end{lstlisting}

Здесь \verb|#include| -- это \emph{директива препроцессора}, с помощью которой включается файл \verb|stdio.h|, в котором есть функция \verb|printf()|, предназначенная для форматированного вывода данных в окно консоли. Так как название файла указано внутри угловых скобок, его поиск будет выполнен в \emph{путях поиска заголовочных файлов}.

Содержимое файла \verb|stdio.h| на одной из стадий компиляции целиком вставляется вместо инструкции с директивой \verb|#include|.

Функция \verb|printf()| содержится внутри файла \verb|stdio.h|, поэтому в первой строке программы мы включаем этот файл с помощью директивы \verb|#include|. Если заголовочный файл не включить, то функция будет недоступна.

После всех \emph{инструкций} указывается точка с запятой. Исключением являются \cite[\strbook{46}]{prokhorenok-prog-c:2020}:
\begin{itemize}
	\item \emph{составные инструкции} (в нашем примере после закрывающей фигурной скобки блока функции \verb|main()| точка с запятой не указывается)
	
	\item и \emph{директивы препроцессоров} (в нашем примере нет точки с запятой после инструкции с директивой \verb|#include|).
\end{itemize}

Согласно стандарту, внутри функции \verb|main()| ключевое слово \verb|return| можно не указывать. В этом случае компилятор должен самостоятельно вставить инструкцию, возвращающую значение~0 \cite[\strbook{46}]{prokhorenok-prog-c:2020}.

Программу можно скомпилировать и без редактора кода. Пример компиляции на ОС Windows
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
gcc -Wall -Wconversion -O3 -finput-charset=cp1251 -fexec-charset=cp1251 -o helloworld.exe helloworld.c
\end{lstlisting}

Первое слово (\verb|gcc|) вызывает компилятор \verb|gcc.exe|. Флаг \verb|-Wall| указывает выводить все предупреждающие сообщения, возникающие во время компиляции программы, флаг \verb|-Wconversion| задает вывод предупреждений при возможной потере данных, а флаг \verb|-O3| определяет уровень оптимизации. С помощью флага \verb|-finput-charset| указывается кодировка файла с программой, а с помощью флага \verb|-fexec-charset| -- кодировка C-строк. Название создаваемого в результате компиляции файла (\verb|helloworld.exe|) задается после флага \verb|-o|. Далее указывается название исходного текстового файла с программой на языке Си (\verb|helloworld.c|).

Помимо файлов с исходным кодом (имеют расширение \verb|*.c|) в проекте могут быть \emph{заголовочные файлы} (имеют расширение \verb|*.h|).

В заголовочных файлах указываются \emph{прототипы функций} и \emph{различные объявления}. Инструкции, начинающиеся с символа \verb|#|, -- это \emph{директивы препроцессора} \cite[\strbook{47}]{prokhorenok-prog-c:2020}.

Например для заголовчного файла с именем \verb|HelloWorld.h|
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
#ifndef HELLOWORLD_H_
#define HELLOWORLD_H_
#endif /* HELLOWORLD_H_ */
\end{lstlisting}

Здесь директива препроцессора \verb|#ifndef| проверяет отсутствие константы с именем \verb|HELLOWORLD_H_|, \verb|#define| -- создает константу с именем \verb|HELLOWORLD_H_|, а \verb|#endif| -- обозначает конец блока проверки отсутствия константы.

Заголовочный файл мы подключаем к файлу с исходным кодом (\verb|*.c|) с помощью директивы \verb|#include|: \verb|#include "HelloWorld.h"| (кавычки!!! а не угловые скобки). Встретив в исходном коде директиву \verb|#include|, \emph{компилятор} вставляет все содержимое заголовочного файла на место директивы. Если мы вставим две одинаковые директивы \verb|#include|, то содержимое заголовочного файла будет вставлено дважды. Чтобы этого избежать прототипы функций и прочие объявления вкладываются в блок, ограниченный директивами \verb|#ifndef| и \verb|#endif|. В директиве \verb|#ifndef| указывается константа, совпадающая с именем заголовочного файла. Все буквы в имени константы заглавные, а точка заменена символом подчеркивания. Если константа не существует (при первом включении так и будет), то с помощью директивы \verb|#define| эта константа создается и содержимое блока вставляется в исходный код. При повторном включении заголовочного файла константа уже существует, поэтому содержимое блока будет проигнорировано. Таким образом, заголовочный файл вставлен не будет, а значит, и ошибки не возникает.

Вместо этих директив в самом начале заголовчного файла можно указать директиву препроцессора \verb|#pragma| со значением \verb|once|, которая также препятствует повторному включению файла (в старых компиляторах директива может не поддреживаться)
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
#pragma once
// Объявление функций и пр.
\end{lstlisting}

Название заголовочного файла в директиве \verb|#include| может быть указано \cite[\strbook{51}]{prokhorenok-prog-c:2020}:
\begin{itemize}
	\item внутри угловых скобок \verb|#include <stdio.h>|,
	
	\item внутри кавычек \verb|#include "HelloWorld.h"|.
\end{itemize}

В первом случае заголовочный файл ищется в путях поиска заголовочных файлов. {При этом \emph{текущий рабочий каталог} \underline{не просматривается}}. Добавить каталог в пути поиска заголовочных файлов позволяет флаг \verb|-I| в команде компиляции. {\color{blue}Обычно с помощью \emph{угловых скобок} включаются заголовочные файлы \emph{стандратной библиотеки} или библиотеки \emph{стороннего разработчика}.}

Во втором случае мы имеем дело с заголовочным файлом, который \emph{вначале} ищется в \emph{текущем рабочем каталоге} (или относительно него), а \emph{затем в путях поиска заголовочных файлов}, как будто название указано внутри угловых скобок. {\color{blue}Таким способом (\verb|#include "HelloWorld.h"|) обычно включаются \emph{заголовочные файлы проекта.}}

Можно указать:
\begin{itemize}
	\item просто название заголовочного файла
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
#include "HelloWorld.h"
\end{lstlisting}

\item абсолютный путь к нему
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
#include "C:\\cpp\\projects\\HelloWorld\\src\\HelloWorld.h"
\end{lstlisting}

\item или относительный путь к нему
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
#include "./HelloWorld.h"
\end{lstlisting}
	
\end{itemize}

\subsection{Компиялция и запуск программы в редакторе Eclipse}

Компиляция в редакторе Eclipse выполняется в два прохода. При первом проходе создается объектный файл \verb|HelloWorld.o|, а на втором проходе на его основе создается исполняемый файл.

По умолчанию для проекта задается \emph{режим компиляции} \verb|Debug|. В этом режиме дополнительно сохраняется информация для отладчика, и EXE-файл будет создан \emph{без оптимизаций}. Когда программа уже написана и отлажена, нужно выбрать режим \verb|Realse|. Для этого в меню \verb|Project| выбираем пункт \menu{Build Configuration > Set Active > Release}.

В результате компиляции в разных режимах были созданы два EXE-файла -- в подкаталоге \verb|Debug| и в подкаталоге \verb|Release|. Первый файл содержит отладочную информацию, а второй -- нет. При компиляции второго была дополнительно выполнена оптимизация, поэтому именно этот файл нужно отдавать заказчику.






\section{Visual Studio Code как среда разработки для языка Cи}

Скачать Visual Studio Code можно здесь \url{https://code.visualstudio.com/}. Для ОС Windows нужно еще установить GCC. На ОС Linux компилятор gcc доступен <<из коробки>>. На ОС MacOS компилятор gcc можно установить с помщью утилиты \verb|brew|.

После установки IDE останется только создать директорию с проектом под язык Си. Когда Visual Studio Code увидит файл с расширением \verb|*.c|, она предложит установить специальное расширение <<C/C++ Extension Pack v1.X.X>>.

\section{Алфавит, идентификаторы, служебные слова}

Идентификаторы, начинающиеся с одного символа подчеркивания <<\verb|_|>> или с двух символов подчеркивания <<\verb*|__|>>, зарезервированы для использования в библиотеках и компиляторах. Поэтому такие идентификаторы не рекомендуется выбирать в качестве имен в прикладной программе на языке Си. Рекомендуется при программировании имена констант записывать целиком заглавными буквами \cite[\strbook{15}]{podbelskiy-prog-c:2005}.

\subsection{Константы и строки}

По определению, константа представляет значение, которое не может быть изменено. Синтаксис языка определяет 5 типов \emph{констант}:
\begin{enumerate}
	\item символы,
	
	\item константы перечисляемого типа,
	
	\item вещественные числа,
	
	\item целые числа,
	
	\item нулевой указатель (<<null>>-указатель).
\end{enumerate}

Управляющие последовательности (\verb*|'\n'|, \verb|'\r'|, etc.) являются частным случаем экскейп-последо\-вательностей (ESC-последовательностей), к которым также относятся лексемы вида \verb*|'\ddd'|, либо \verb|'\xhh'|.

\emph{Символьная константа} (символ) имеет \emph{целый тип}, то есть символы можно использовать в качестве целочисленных операндов в выражениях.

Целочисленные именованные константы можно вводить с помощью перечисления \verb*|enum|. Пример
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
enum DAY {SUNDAY, MONDAY, ...};
enum BOOLEAN {NO, YES};
\end{lstlisting}

В первой строке \verb*|DAY|, а во второй строке \verb|BOOLEAN| это необязательный произвольный идентификатор -- название перечисления.

Если в списке нет ни одного элемента со знаком \verb*|'='|, то значения констант начинаются с 0 и увеличиваются на 1 слева направо. Таким образом, \verb|NO| равно 0, а \verb*|YES| -- 1. Именованная константа со знаком \verb|'='| получает соответствующее значение, а следующая за ней именованные константы без явных значений увеличиваются на 1 каждая.

То есть если 
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
enum BOOLEAN {NO=10, YES};
printf("NO=%d, YES=%d", NO, YES);  // NO=10, YES=11
\end{lstlisting}

В Python можно сделать так
\begin{lstlisting}[
style = ironpython,
numbers = none	
]
from enum import Enum, auto

class Boolean(Enum):
    NO = 0
    YES = auto()
    
Boolean.NO.value  # 0
Boolean.YES.value  # 1
\end{lstlisting}

Формально строки не относятся к константам языка Си, а представляют собой отдельный тип его лексем. Строковая константа определяется как последовательность символов, заключенных в двойные кавычки (не в апострофы).

Представление \emph{строковых констант} в памяти ЭВМ подчиняются следующим правилам. Все символы строки размещаются подряд, и каждый символ (в том числе представленный эскейп-последовательностью) занимает ровно 1 байт. В конце записи строковой константы компилятор помещает символ \verb*|'\0'|.

Таким образом, количество байтов, выделяемое в памяти ЭВМ для представления значения строки, ровно на 1 больше, чем число символов в записи этой строковой константы.

При работе с символьной информацией нужно помнить, что длина символьной константы \verb*|'F'| равна 1 байту, а длина строки \verb|"F"| равна 2 байтам.

\subsection{Переменные и именованные константы}

Одним из основных понятий языка Си является \emph{объект} -- именованная область памяти. Частный случай объекта -- переменная.

Каждый из целочисленных типов (\verb|char|, \verb*|short|, \verb|int|, \verb*|long|) может быть определен либо как \emph{знаковый} \verb|signed| либо как \emph{беззнаковый} \verb*|unsigned| (по умолчанию \verb|signed|). 

Различие между этими двумя типами -- в правилах интерпретации \emph{старшего бита внутреннего представления}. Спецификатор \verb*|signed| означает, что старший бит внутреннего представления воспринимался как знаковый; \verb|unsigned| означает, что старший бит внутренного представления входит в код представляемого числового значения, которое считается в этом случае беззнаковым. Выбор знакового или беззнакового представления определяет предельные значения, которые можно представить с помощью описанной переменной. Например на IBM PC переменная типа \verb|unsigned int| позволяет представить числа от 0 до 65 535, а переменная типа \verb*|signed int| (или просто \verb*|int|) соответствуют значения в диапазоне от -32768 до +32767. 

Именованные константы можно вводить с помощью \emph{директивы препроцессора} \verb|#define|, напрмер
\begin{lstlisting}[
style = c_cpp,
numbers = none,
]
// препроцессорная константа
#define EULER 2.718282  // точка с запятой не нужна!!!
\end{lstlisting}

Что эквивалентно
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
const double EULER = 2.718282;
\end{lstlisting}

До начала компиляции текст программы на языке Си обрабатывается специальным компонентом транслятора -- \emph{препроцессором}. Далее текст от препроцессора поступает к компилятору. Итак, основное отличие констант, определяемых \emph{препроцессорными директивами} \verb*|#define|, состоит в том, что эти \emph{константы вводятся} в текст программы \emph{до этапа компиляции} -- препроцессор обрабатывает исходный код программы и делает в этом тексте замены и подстановки \cite[\strbook{29}]{podbelskiy-prog-c:2005}.

\section{Директивы препроцессора}

Задача препроцессора -- заменить специальные директивы подходящим кодом на Си и подготовить итоговые исходники к компиляции.  Управлять препроцессором в Си и влиять на его поведение можно с помощью набора \emph{директив}. Они представляют собой строчки кода, начинающиеся символом \verb|#| как в заголовочных, так и в исходных файлах. Эти строчки имеют смысл \emph{только для препроцессора}, \emph{но не для компилятора}.

Макросы можно применять различными способами. Ниже перечислено несколько примеров \cite[\strbook{28}]{amini-extreme-c:2022}
\begin{itemize}
	\item определение константы,
	
	\item использование вместо обычной функции на Си,
	
	\item разворачиваение цикла,
	
	\item предотвращение дублирования,
	
	\item условная компиляция.
\end{itemize}

\subsection{Макросы}

Для \emph{определения макросов} используется \emph{директива} \verb|#define|. Каждый макрос имеет имя и (иногда) список параметров. У него также есть значение, которое подставляется вместо его имени на этапе работы \emph{препроцессора} под названием <<\emph{развертывание макроса}>>. С помощью директивы \verb|#undef| макрос можно сделать \emph{неопределенным}.

\begin{lstlisting}[
style = c_cpp,
numbers = none
]
#define ABC 5  // макрос

int main(int argc, char *argv[]) {
    int x = 2;
    int y = ABC;
    
    int z = x + y;
    return 0;
}
\end{lstlisting}

В приведенном выше листенге \verb|ABC| -- не переменная с целочисленным значением и не целочисленная константа. На самом деле это \emph{макрос} с именем \verb|ABC|, значение которого равно 5.

Препроцессор развернет макрос, подставив его значение туда, где было указано его имя, и вдобавок уберет комментарий в начальной точке.

Определение \emph{функционального макроса}
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
#define ADD(a, b) (a + b)  // функциональный макрос

int main(int argc, char **argv) {
    int x = 2;
    int y = 3;
    int z = ADD(x, y);  // после обработки эта строка будет выглядеть так: int z = x + y;
    return 0;
}
\end{lstlisting}

\verb|ADD| не является функцией. Это всего лишь \emph{функциональный макрос}, который принимает аргументы.

Поскольку функциональные макросы могут принимать аргументы, с их помощью можно имитировать функции Си. Иными словами, можно вынести часто используемую логику в функциональный макрос \cite[\strbook{30}]{amini-extreme-c:2022}.

Макросы существуют \emph{только перед этапом компиляции}. То есть компилятор теоретически нечего о них не знает. О функциях компилятор знает все, поскольку они являются частью грамматики языка Си и храняться в синтаксическом дереве. А макрос -- просто директива, которую понимает только препроцессор.

Современные компиляторы Си знают о директивах и анализируют исходный код еще до его обработки препроцессором \cite[\strbook{30}]{amini-extreme-c:2022}.

Большинство современных компиляторов позволяют просматривать результаты работы препроцессора непосредственно перед компиляцией. Например, можно указать флаг \verb|-E|, чтобы вывести обработанный препроцессором код
\begin{lstlisting}[
style = bash,
numbers = none
]
$ gcc -E main.c > gcc.out
\end{lstlisting}

\emph{Единица трасляции} (или \emph{единица компиляции}) -- код на языке Си, который прошел через препроцессор и готов к компиляции. В \emph{единице трасляции} все директивы заменены \emph{подключенными файлами} или \emph{развернутыми макросами}, благодаря чему получается один длинный блок кода на Си.

Пример
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
#define PRINT(value) printf("%d\n", value);
#define LOOP(var, init_value, upper_bound) for (int var = init_value; var < upper_bound; var++) {
#define ENDLOOP }

int main(int argc, char **argv) {
    LOOP(counter, 0, 5)
        PRINT(counter)
    ENDLOOP
}
\end{lstlisting}

Пример использования операторов \verb|#| и \verb|##|
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
#include <stdio.h>
#include <string.h>

#define CMD(NAME) \
    char NAME ## _cmd[256] = ""; \
    strcpy(NAME ## _cmd, #NAME);
    
int main(int argc, char **argv) {  // char *argv[]
    CMD(copy)  // char copy_cmd[256] = ""; strcpy(copy_cmd, "copy");
    CMD(paste)
    
    char cmd[256];
    printf("Enter command: ");
    scanf("%s", cmd);
    
    if (strcmp(cmd, copy_cmd) == 0) {
        // ...
    }
    if (strcmp(cmd, paste_cmd) == 0) {
        // ...
    }
}
\end{lstlisting}

При развертывании макроса оператор \verb|#| переводит параметр в строковую форму, заключенную в кавычки. Например, \verb|NAME| в \verb|"copy"|. А оператор \verb|##| соединяет параметры с другими элементами в определении макроса -- обычно в целях формирования имен переменных.

\subsubsection{Вариативные макросы}

Вариативные макросы могут принимать переменное число аргументов
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// препроцессорная константа
#define VERSION "2.3.4"

// вариативный макрос
#define LOG_ERROR(format, ...) \
    fprintf(stderr, format, __VA_ARGS__)
    
int main(int argc, char **argv) {
    if (argc < 3) {
        LOG_ERROR("Invalid number of arguments for version %s\n", VERSION);
    }
    
    if (strcmp(argv[1], "-n") != 0) {
        LOG_ERROR("%s is a wrong param at index %d for version %s", argv[1], 1, VERSION);
    }
}
\end{lstlisting}

Согласно определениею макроса входящие аргументы \verb|argv[1]|, \verb|1| и \verb|VERSION| \emph{НЕ} присваиваются ни одному из параметров. Поэтому при развертывании макроса они будут использованы вместо \verb|__VA_ARGS__|
\begin{lstlisting}[
style = bash,
numbers = none
]
$ ./sample 10
# Invalid number of arguments for version 2.3.4
\end{lstlisting}

Имитировать цикл с помощью макроса можно только одним способом: разместить отдельные повторяющиеся инструкции одна за другой. Это значит, что простой цикл с 1000 итерациями превратиться в 1000 инструкций в коде на Си и в результате у нас не будет никакого реального цикла.

Использование представленного выше метода увеличивает размер двоичного файла, что можно считать недостатком. Размещение инструкций друг за другом вместо того, чтобы выполнять их в цикле, называется \emph{развертыванием цикла} (loop unrolling) и хорошо подходит в определенных ситуациях: например, когда нужен приемлемый уровень производительности независимо от того, сколько ресурсов доступно в той или иной среде. Развертывание цикла можно считать компромиссом между размером двоичного файла и производительностью \cite[\strbook{38}]{amini-extreme-c:2022}.

Архитекторы и проетировщики ПО руководствуются следующим правилом: <<Если макрос можно оформить в виде функции яызка Си, то нужно делать выбор в пользу функции!>>

Когда проект разрабатывается в соответствии с общепринятыми принципами проектирования ПО, он обычно состоит из \emph{множества легковесных двоичных файлов} с минимально допустимыми размерами, а не из одного огромного исполняемого файла \cite[\strbook{40}]{amini-extreme-c:2022}.

Если нужна высокая производительность, то иногда приходится жертвовать стройной архитектурой и размещять компоненты линейно. Например, можно развернуть свои циклы.

В ходе проектирования мы пытаемся организовать компоненты в виде иерархии и избавиться от линейности, но центральный процессор рассчитан на то, что все инструкции уже загружены в линейном порядке и готовы к обработке. 

Обсудим \emph{развертывание циклов}. Эта методика в основном применяется в разработке для встраиваемых систем и \emph{особенно в средах с ограниченными вычислительными ресурсами}. Она представляет собой \emph{замену циклов линейными инструкциями}, что улучшает производительность и избавляет от накладных расходов на циклическое выполнение \cite[\strbook{41}]{amini-extreme-c:2022}.

\subsection{Условная компиляция}

Условная компиляция -- еще одна уникальная особенность Си. Она позволяет препроцессору генерировать разный исходный код в зависимости от тех или иных обстоятельств. В условной компиляции могут участвовать разные директивы:
\begin{itemize}
	\item \verb|#ifdef|,
	
	\item \verb|#ifndef|,
	
	\item \verb|#else|,
	
	\item \verb|#elif|,
	
	\item \verb|#endif|
\end{itemize}

Пример
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
#define CONDITION

int main(int argc, char **argv) {
#ifdef CONDITION
    int i = 0;
    i++;
#endif
    int j = 0;
    return 0;
}
\end{lstlisting}

Макросы можно определять, передавая команде компиляции параметры \verb|-D|
\begin{lstlisting}[
style = bash,
numbers = none
]
$ gcc -DCONDITION -E main.c
\end{lstlisting}

Она особенно полезна, когда один и тот же исходник необходимо скомпилировать для разных архитектур, таких как Linux или macOS, с разными библиотеками и определениями макросов по умолчанию
\begin{lstlisting}[
style = bash,
numbers = none
]
$ gcc -DCONDITION -o main main.c
$ ./main
\end{lstlisting}

Директива \verb|#ifndef| часто используется для \emph{предотвращения дублирования заголовков}. Она не позволяет препроцессору подключить один и тот же заголовк дважды
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
#ifndef EXAMPLE_1_8_H
#define EXAMPLE_1_8_H

void say_hello();
int read_age();

#endif /* EXAMPLE_1_8_H */
\end{lstlisting}

Определения всех переменных и функций находится между \verb|#ifndef| и \verb|#endif|, что защищает их от повторного включения.

Когда заголовок подключается в первый раз, \emph{макрос} \verb|EXAMPLE_1_8_H| все еще не определен, поэтому препроцессор заходит в блок \verb|#ifndef-#endif|. Следующая инструкция определяет макрос \verb|EXAMPLE_1_8_H|, и препроцессор копирует в преобразованный код все, что находится выше директивы \verb|#endif|. Когда происходит второе включение, макрос \verb|EXAMPLE_1_8_H| уже определен, поэтому препроцессор пропускает все содержимое блока и переходит к следующей за \verb|#endif| инструкцией, если таковая имеется.

Между \verb|#ifndef-#endif| обычно размещают все содержимое заголовочного файла, а снаружи остаются лишь комментарии.

Для защиты от \emph{двойного включения} вместо пары \verb|#ifndef-#endif| можно использовать одну директиву \verb|#pragma once|. Ее единственной особенностью является то, что, несмотря на поддержку в почти всех препроцессорах, она не входит в стандарт Си. Поэтому если ваш код должен быть переносимым, то от нее лучше отказаться.
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
#pragma once  // вместо #ifndef-#endif

void say_hello();
int read_age();
\end{lstlisting}  

\section{Указатели на переменные}

Указатели в случае некорректного использования могут привести к катастрофическим последствиям. В основе любого \emph{указателя} лежит простая идея; это всего лишь \emph{обычная переменная}, которая хранит \emph{адрес памяти} \cite[\strbook{45}]{amini-extreme-c:2022}.

Все эти объявления будут корректными с точки зрения Си:
\begin{itemize}
	\item \verb|int* ptr = 0;|
	
	\item \verb|int * ptr = 0;|
	
	\item \verb|int *ptr = 0;|
\end{itemize}

\emph{Оператор разыменования} \verb|*| открывает непрямой доступ к ячейки памяти, на которую указывает указатель. Иными словами, он позволяет считывать и модифицировать переменную через указатель, который на нее ссылается.

Нулевой указатель не содержит действительного адреса памяти. Следует избегать его разыменования, поскольку оно приводит к \emph{неопределенному поведению} (что обычно заканчивается сбоем программы).

Обычно нам доступен \emph{макрос} \verb|NULL| со значением 0, который можно использовать для \emph{обнуления указателей} в момент их \emph{объявления}. Этому макросу следует отдавать предпочтение, поскольку он помогает отличать обычные переменные от указателей.

{\color{blue}\emph{Указатели} обязательно нужно \emph{инициализировать} во время \emph{объявления}!}

На каждой платформе все указатели, хранящиеся в памяти, должны занимать ячейки определенного размера, то есть содержать одинаковое количество байтов. Но это вовсе не значит, что все они имеют одну и ту же длину арифметического шага.

Например, указатели типа \verb|int| и \verb|char| имеют одинаковый размер, но длина их арифметического шага отличается: \verb|int*| обычно имеет четырхбайтный шаг, а \verb|char*| -- однобайтный. Следовательно, при инкрементировании целочисленного указателя мы перемещаемся в памяти на четыре байта вперед (добавляем 4 байта к текущему адресу), а инкрементация указателя на тип \verb|char| приводит к перемещению вперед на 1 байт.

\subsection{Обобщенные указатели}

Указатели типа \verb|void *| называют \emph{обобщенными} \cite[\strbook{50}]{amini-extreme-c:2022} (в книге \cite{prokhorenok-prog-c:2020} они называются нетипизированными указателями). Как и любые другие указатели, они могут ссылаться на любой адрес, но \emph{их фактический тип данных неизвестен}, поэтому мы не знаем длину их арифметического шага. Обобщенные указатели обычно используются для хранения содержимого других указателей без запоминания их типов. В связи с этим \emph{их нельзя разыменовывать} и с ними \emph{невозможно  проводить арифметические операции}, поскольку мы не знаем их тип данных. 

{\color{blue} Большинство компиляторов запрещают разыменование обобщенных указателей}

Длина шагов \verb|char *| и \verb|unsigned char *| равна 1 байту. Это делает данный тип указателей наиболее подходящим для побайтового перебора адресов в заданном диапазоне и их обработки байт за байтом.

\verb|size_t| -- это \emph{стандартный} беззнаковый тип данных, который в языке Си обычно используется \emph{для хранения размеров} \cite[\strbook{52}]{amini-extreme-c:2022}.

Функция \verb|size_t| описана в подразделе 6.5.3.4 стандарта ISO/ICE:9899:TC3 (спецификация С99), пересмотренная в 2007 году. На сегодняшний день она является основой для всех реализаций Си. Текст стандарта доступен по ссылке \url{www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf}.

\subsection{Размер указателей}

Размер указателя не является понятием языка программирования как такового, а зависит от конкретной архитектуры. Язык Си мало знаает о подобных подробностях, относящихся к аппаратному обеспечению; он пытается предоставить универсальный способ работы с указателями и другими аспектами программирования. Именно поэтому язык Си является стандартом; в нем описываются только сами указатели и их арфиметика \cite[\strbook{53}]{amini-extreme-c:2022}.

Функцию \verb|sizeof| всегда можно использовать для получения размера указателя. Достаточно проверить результат \verb|sizeof(char *)| в вашей текущей архитектуре. В 32- и 64-битных архитектурах указатели, как правило, занимают соответственно 4 и 8 байт, однако в некоторых системах могут иметь другой размер.

\subsection{Висячие указатели}

Указатель обычно содержит \emph{адрес} \underline{\itshape участка памяти}, выделенного для переменной \cite[\strbook{53}]{amini-extreme-c:2022}. Чтение или изменение адреса, по которому не зарегистрировано никакой переменной, считается большой оплошностью и может привести к сбою программы или \emph{ошибке сегментации}. Она обычно возникает при неправильном использовании указателей. Вы обращаетесь к участку памяти, к которому у вас нет доступа. Раньше там находилась ваша переменная, но к моменту обращения она уже не существует.

Пример висячего указателя
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
#include <stdio.h>

int *create_an_integer(int default_value) {
    int var = default_value;
    
    return &var;
}

int main() {
    int *ptr = NULL;
    ptr = create_an_integer(10);  // получится висячий указатель
    printf("%d\n", *ptr);
}
\end{lstlisting}

На MacOS проблемы висячего указателя не возникает, но на Linux будут проблемы. Указатель \verb|ptr| -- висячий, поскольку участок памяти, на который он ссылается (принадлежит переменной \verb|var|), уже освобожден. Но вместе с тем функция возвращает адрес переменной, который затем присваивается указателю \verb|ptr| внутри \verb|main|.

Исправить ошибку можно с помощью \emph{выделения кучи}
\begin{lstlisting}[
style = c_cpp,
numbers = none	
]
#include <stdio.h>
#include <stdlib.h>

int *create_an_integer(int default_value) {
    int *var_ptr = (int *)malloc(sizeof(int));
    *var_ptr = default_value;
    
    return var_ptr;
}

int main() {
	int *ptr = NULL;
    *ptr = create_an_integer(10);
    pritnf("%d\n", *ptr);
    free(ptr);
}
\end{lstlisting}

Теперь переменная, которая создается внутри функции \verb|create_an_integer|, \emph{больше не является локальной}. Она \emph{выделяется в куче}, и ее время жизни не ограничено функцией, в которой была объявлена. Следовательно, к ней может обратиться вызывающая (внешняя) функция. Указатели, ссылающиеся на эту переменную, больше не висячие, и их можно разыменовывать \cite[\strbook{56}]{amini-extreme-c:2022}.

В конце своего жизненного цикла переменная освобождается путем вызова функции \verb|free|. Обратите внимание: любое содержимое кучи, которое больше не нуждается, нужно обязательно освобождать.

В Си, как и во многих других языках программирования, на которые он повлиял, \emph{функции возвращают лишь одно значение}. В Си все функции \emph{блокирующие}. Это означает, что вызывающий код, ждет пока они не закончат работу, и только потом собирает возвращенные результаты \cite[\strbook{56}]{amini-extreme-c:2022}.

Помимо блокирующих функций, существуют и \emph{неблокирующие}. Вызывающий код может продолжать выполняться, не дожидаясь их завершения. В таком случае обычно используется механизм обратных вызовов, которые срабатывают, когда вызванная функция завершает работу. Неблокирующие функции также иногда называют \emph{асинхронными}. Поскольку в Си они не существуют, для их реализации применяются многопоточные решения.

\emph{Стек} -- участок памяти, которые по умолчанию выделяется для \emph{всех локальных переменных}, \emph{массивов} и \emph{структур}. Поэтому, когда вы объявляете \emph{локальную переменную} в функции, она \emph{\color{blue}всегда создается в стеке} -- а если точнее, на его вершине \cite[\strbook{57}]{amini-extreme-c:2022}.

Стек используется еще и для вызова функций. Перед началом выполнения новой функции ее адрес возврата и все передаваемые ей аргументы собираются в \emph{стековый фрейм} и кладутся на вершину стека. Когда эта функция завершается, фрейм извлекает из стека, после чего начинают выполняться инструкции, находящиеся по адресу возврата (это обычно приводит к продолжению работы вызывающей функции).

\emph{Все локальные переменные}, объявленные в теле функции, помещаются \underline{\itshape на вершину стека}. Как следствие, все они освобождаются по завершении функции. Именно поэтому мы называем их локальными переменными и можем быть уверены в том, что одна функция не имеет доступа к переменным другой.

В языке Си аргументы в функцию можно передать \emph{только по значению}!!! В Си \emph{нет никаких ссылок}, что делает передачу по ссылке невозможной. {\color{blue}Все, что передается функции, \emph{копируется} в ее локальные переменные и перестает быть доступным, когда она завершается.} \cite[\strbook{60}]{amini-extreme-c:2022}

\emph{Указатель} передается в функцию \emph{по значению} (копируется). Разыменование данного указателя внутри функции позволяет обратиться к переменной, на которую он ссылается.

Обычно в качетве аргументов рекомендуется использовать указатели, а не крупные объекты, и несложно догадаться почему. Копирование 8-байтного указателя куда более эффективно, чем копирование большого объекта, занимающего сотни байтов.

В языке Си во время вызова \emph{все аргументы передаются по значению}, а разыменование указателей позволяет менять переменные вызывающей функции \cite[\strbook{60}]{amini-extreme-c:2022}.

\emph{Структуры} и \emph{массивы} копируются последовательно, байт за байтом, поэтому их \emph{лучше передавать по указателю}.

\subsection{Указатели на функции}

Указатель на переменную содержит ее адрес. Точно так же указатель на функцию содержит ее адрес, позволяя вызывать ее опосредованным образом. 
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
#include <stdio.h>

int sum(int a, int b) {
    return a + b;
}

int substract(int a, int b) {
    return a - b;
}

int main() {
    int (*func_ptr) (int, int);  // указатель на функцию
    func_ptr = NULL;  // обязательно!
    
    func_ptr = &sum;  // можно просто func_ptr = sum;
    int result = func_ptr(5, 4);
    printf("Sum: %d\n", result);
    
    func_ptr = &substract;  // можно просто func_ptr = substract;
    result = func_ptr(5, 4);
    printf("Subtract: %d\n", result);
}
\end{lstlisting}

В данном примере \verb|fptr| -- указатель, который может ссылаться только на определенный вид функций, соответствующих его сигнатуре. Это означает, что функции, адрес которых он содержит, должны принимать два целочисленных аргумента и возвращать целочисленный результат.

{\color{blue}Указатели на функции, как и любые другие, \underline{\itshape необходимо} как следует \underline{\itshape инициализировать}. Если \emph{указатель} не инициализируется непосредственно во время объявления, то его \emph{обязательно необходимо обнулить}}. Для \emph{указателей на функции} обычно рекомендуется определить новый \emph{пседоним типа}
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
#include <stdio.h>

typedef int bool_t;  // псевдоним типа, добавляется "_t"
typedef bool_t (*less_than_func_t) (int, int);  // псевдоним типа, добавляется "_t"

bool_t less_than(int a, int b) {
    return a < b ? 1 : 0;
}

bool_t less_than_modular(int a, int b) {
    return (a % 5) < (b % 5) ? 1 : 0;
}

int main(int argc, char** argv) {  // char *argv[]
    less_than_func_t func_ptr = NULL;  // обязательно!
    
    func_ptr = &less_than;
    bool_t result = func_ptr(3, 7);
    printf("%d\n", result);
}
\end{lstlisting}

Ключевое слово \verb|typedef| позволяет определить псевдоним для уже существующего типа. В приведенном выше примере используются два таких пседонима: \verb|bool_t| для типа \verb|int| и \verb|less_than_func_t| для указателей на функции типа \verb|bool_t(*)(int, int)|. Благодаря этому код более понятен и можно выбирать более короткое имя длинного и сложного типа.

В Си к именам \emph{новых типов} принято добавлять \verb|_t|; это соглашение об именовании соблюдается во многих других стандартных пседонимах, таких как \verb|sizt_t| и \verb|time_t|.

Если требуется определить собственные, пользовательские типы данных, не предусмотренные в самом языке, то нужны структуры. 

Обратите внимание: ключевое слово \verb|typedef| не имеет никакого отношения к пользовательским типам. Оно лишь создает \emph{пседоним для типов}, которые \underline{уже существуют}. Если программе требуются совершенно новые типы, то следует задействовать \emph{структуры}.

При объявлении структурной переменной в Си необходимо указать ключевое слово \verb|struct|, например, \verb|struct sample_t var|, в котором \verb|struct| находится перед структурным типом \verb*|sample_t|. Для доступа к полям \emph{структурной переменной} используется символ \verb|.| или \verb*|->|.

Если вы не хотите набирать \verb|struct| при определении каждого нового структурного типа и объявления каждой структурной переменной, то можете создать \emph{для своих структур псевдонимы}. Используйте для этого \verb|typedef|
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
typedef struct {
    char first;
    char second;
    char third;
    short fourth;
} sample_t;
\end{lstlisting}

Теперь можно \emph{объявить структурную переменную}, не прибегая к использованию ключевого слова \verb|struct|
\begin{lstlisting}[
style = c_cpp,
numbers = none	
]
sample_t var;
\end{lstlisting}

По своему размещению в памяти \emph{структурная переменная} очень похожа на \emph{массив}. В нем все элементы размещаются в памяти последовательно; то же самое относится к структурной переменной и ее полям. Разница лишь в том, что в \emph{массиве} \emph{все элементы имеют один и тот же тип} и, следовательно, одинаковый размер, чего нельзя сказать о структурных переменных. В структуре каждое поле может иметь свой тип и размер.

Выравнивание данных в памяти. Прежде чем совершать какие-либо вычисления, процессор должен сначала загрузить из памяти подходящие значения, а затем сохранить полученный результат обратно в память. 

Вычисления сами по себе происходят невероятно быстро, но доступ к памяти выполняется сравнительно медленно.

Обычно при каждом обращении к памяти процессор считывает определенное количество байтов. Эту величину принято называть \emph{машинным словом}. Таким образом, память поделена на машинные слова, каждое из которых является атомарной единицей чтения и записи. Количество байтов в машинном слове зависит от архитектуры. Например, в большинстве 64-битных компьютеров слово занимает 32 бита, или 4 байта. Касательно выравнивания принято считать, что переменная выровнена в памяти, если ее первый байт совпадает с началом машинного слова. Так процессор может оптимизировать обращения к памяти, необходимые для загрузки ее значений \cite[\strbook{68}]{amini-extreme-c:2022}.

Получается, что процессор читает и пишет данные \emph{машинными словами}.

Например в структуре
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
struct sample_t {
    char first;  // 1 байт
    char second;  // 1 байт
    char third;  // 1 байт
    short fourth;  // 2 байта
};
\end{lstlisting}
первые три поля занимают по 1 байту и находятся в первом машинном слове структуры; \emph{все они могут быть прочитаны за одно обращение к памяти}. А вот четвертое поле, занимает 2 байта. Если забыть о выравнивании данных в памяти, то его начальный байт должен стать последним байтом первого машинного слова \cite[\strbook{68}]{amini-extreme-c:2022}.

В подобном случае для загрузки значения данного поля из памяти \emph{процессору} пришлось бы выполнить \emph{два обращения к памяти} и заодно сместить определенные биты. Можно сказать, что первое машинное слово дополняется одним нулевым байтом. Этот нулевой байт был добавлен с целью завершить текущее слово и начать новое с четвертого поля.

Компилятор использует \emph{дополнительные байты} для \underline{выравнивания значений в памяти}.

Сложные типы данных
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
typedef struct {
    int x;
    int y;
} point_t;

typedef struct {
    point_t center;
    int radius;
} circle_t;

typedef struct {
    point_t start;
    point_t end;
} line_t;
\end{lstlisting}

Размер сложных и простых структур вычисляется одним и тем же способом: путем сложения размеров всех полей. Конечно, не стоит забывать о выравнивании, которое может повлиять на размер сложной структуры. Так, если \verb|sizeof(int)| равно 4 байтам, то \verb|sizeof(point_t)| будет равно 8 байтам. Точно так же \verb|sizeof(circle_t)| и \verb|sizeof(line_t)| равны 12 и 16 байтам соответственно.

\emph{Структурные переменные} часто называют \emph{объектами}. Они выступают прямыми аналогами объектов в объектно-ориентированном программировании и могут помимо значений инкапсулировать и функции \cite[\strbook{70}]{amini-extreme-c:2022}.

\emph{Структурный указатель} (то есть указатель на структуру) ссылается на \underline{\itshape адрес} \emph{первого поля} структурной переменной. С точки зрения размещения в памяти структурные переменные очень похоже на массивы, в том смысле, что поля структуры размещаются в памяти последовательно.

Указатель на \verb|circle_t| храрнил адрес своего первого поля \verb|center|; но, поскольку это поле в действительности являлось объектом (структурой) \verb|point_t|, данный указатель фактически ссылался на первое поле этого объекта, \verb|x|. Таким образом, у нас может быть три указателя с адресом одной и той же ячейки памяти.
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
#include <stdio.h>

typedef struct {
    int x;
    int y;
} point_t;

typedef struct {
    point_t center;
    int radius;
} circle_t;

int main(int argc, char** argv) {
    circle_t c;  // объявляем структурную переменную
    circle_t* p1 = &c;
    point_t* p2 = (point_t*)&c;
    int* p3 = (int*)&c;
    
    printf("p1: %p\n", (void*)p1);
    printf("p2: %p\n", (void*)p2);
    printf("p3: %p\n", (void*)p3);
}
\end{lstlisting}

\section{Сброка проекта на языке Си}

Заголовочный файл обычно содержит перечисления, макросы и определения типов, а также \emph{объявления} функций, глобальных переменных и структур. В языке Си объявление и определение некоторых элементов программирования, таких как функции, переменные и структуры, могут находиться в разных файлах.

\emph{Объявления} принято хранить в заголовочных файлах, а соответствующие \emph{определения} -- в исходных. \emph{Объявления функций} настоятельно рекомендуется размещать в заголовочных файлах, а их \emph{определения} -- в соответствующих исходных файлах.

К заголовочным файлам можно подключать только другие заголовочные файлы, но не исходники. К исходным файлам можно подключать только заголовочные файлы. {\color{red}Подключение одних заголовочных файлов к другим считается дурным тоном.} Если вы так делаете, то это обычно говорит о серьезной проблеме в архитектуре вашего проекта.

Возвращаемый тип входит в состав объявления, но редко считается частью сигнатуры функции. Параметры функции рекомендуется именовать даже при объявлении.

Функция \verb|main| является \emph{точкой входа} в программу. Без нее нельзя получить двоичный файл для запуска программы. Эта функция интерпретируется компилятором как место, с которого нужно начинать выполнение.

Пример заголовочного файла
\begin{lstlisting}[
title = {\sffamily ExtremeC\_examples\_charpter2\_1.h},
style = c_cpp,
numbers = none
]
#ifndef EXTREMEC_EXAMPLES_CHAPTER_2_1_H
#define EXTREMEC_EXAMPLES_CHAPTER_2_1_H

typedef enum {
    NONE,
    NORMAL,
    SQUARED
} average_type_t;

// объявление функции
double avg(int*, int, average_type_t);

#endif
\end{lstlisting}

В языке Си у \emph{перечислений} не может быть отдельных объявлений и определений: они должны \emph{объявляться} и \emph{определяться} в одном и том же месте.

В любом проекте на языке Си функция \verb|main| служит точкой входа в программу. Сборка проекта на C/C++ требует компиляции его ководой базы в переносимые объектные файлы (которые еще называют промежуточными) и затем объединения их в конечные продукты, такие как \emph{статические библиотеки} или \emph{исполняемые файлы}.

В других языках программирования сборка проходит аналогичным образом, только промежуточные и конечные продукты будут иметь другие имена и, скорее всего, другие форматы. Например, в Java промежуточными продуктами выступают class-файлы с байт-кодом, а конечными -- JAR- или WAR-файлы.

Два важных правила \cite[\strbook{82}]{amini-extreme-c:2022}:
\begin{enumerate}
	\item Компилируются \emph{только исходные файлы}. Заголовочные файлы не должны содержать ничего, кроме объявлений. 
	
	\item \emph{Каждый исходный файл} компилируется \underline{\itshape по отдельности}. Таким образом, если проект состоит из 100 исходных файлов, то придется скомпилировать каждый из них отдельно; то есть компилятор нужно будет запустить 100 раз! Можно подумать, что это много, но именно так следует компилировать проекты на C/C++. 
\end{enumerate}

К исходному файлу не подключаются другие исходники, поэтому он всегда компилируется отдельно. Согласно общепринятым рекомендациям, исходные файлы в C/C++ подключать нельзя!

Рассмотрим подробнее этапы сборки проекта на Си.

\subsection{Этап 1. Предобработка}

Это первый этап компиляции. К исходному файлу подключается ряд заголовочных. Иными словами, после предобработки мы получаем один фрагмент кода на языке Си, сформированный путем копирования заголовочных файлов в исходные.

Код, прошедший такую обработку, называется \emph{единицей трансляции} (или \emph{единицей компиляции}). Единица трансляции -- это отдельный логический болок кода на Си, сгенерированный препроцессором и готовый к компиляции. В единице трансляции не остается ни одной директивы препроцессора!

Все объявления из заголовочного файла были скопированы в единицу трансляции, а все комментарии -- удалены. Итак, на вход поступает \emph{исходный файл}, а на выходе получается соответствующая \emph{единица трансляции}.

\subsection{Этап 2. Компиляция в ассемблерный код}

После получения единицы трансляции можно переходить ко второму этапу -- \emph{компиляции}. На вход подается единица компиляции, полученная на предыдущем этапе, а на выходе получается соответствующий \emph{ассемблерный код}. Он все еще может быть прочитан человеком, но уже зависит от аппаратной архитектуры и приближен к оборудованию. 

Сохранить полученный ассемблерный код можно, передав компилятору \verb|gcc| параметр \verb|-S|. Итоговый файл будет иметь то же имя, что и исходник, только с раширением \verb|*.s|
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
$ gcc -S main.c
\end{lstlisting}

В рамках данного этапа компилятор анализирует единицу трансляции и превращает ее в ассемблерный код, рассчитанный на целевую архитектуру. Под таковой понимается аппаратное обеспечение или центральный процессор, на котором будет выполняться скомпилированная программа.

Для нескольких архитектур может быть сгенерирован разный ассемблерный код. И это не смотря на тот факт, что использовался один и тот же исходный код на Си. 

Целевой называется архитектурой, для которой компилируется исходный файл и на которой будет выполняться программа. Архитектура сборки используется для компиляции исходника и может отличаться от целевой. Например, исходный код на Си можно скомпилировать для 64-битного процессора AMD, используя 32-битный компьютер ARM.

Ассемблерный код крайне близок к языку, который понимает центральный процессор.

\subsection{Этап 3. Компиляция в машинные инструкции}

Цель -- сгенерирровать инструкции машинного уровня (или \emph{машинный код}) на основе \emph{ассемблерного кода}, созданного компилятором на предыдущем этапе. 

У каждой архитектуры есть свой \emph{ассемблер}, который может преобразовать собственный ассемблерный код в машинные инструкции. Объектные файлы -- файлы с машинными инструкциями.

\emph{Двоичный файл} и \emph{объектный файл} содержат машинные интсрукции и являются синонимами.

В большинстве Unix-подобных операционных систем есть утилита под названием \verb|as|, с помощью которой \emph{ассемблерный код} можно превратить в \emph{переносимый объектный файл}.

Однако эти \emph{объектные файлы} \underline{не являются исполняемыми}; они содержат только те \emph{машинные интсрукции}, которые были сгенерированы для единицы трансляции. Таким образом, в объектном файле находятся машинные инструкции лишь для соответствующих функций и предварительно выделенных глобальных переменных.

\begin{lstlisting}[
style = c_cpp,
numbers = none
]
$ as main.s -o main.o
\end{lstlisting}

Переносимые объектные файлы обычно имеют расширение \verb|*.o| (или \verb|*.obj| в Microsoft Windows).

Содержимое объектного файла \emph{нельзя} представить \emph{в текстовом виде}, и потому вам не удастся его прочитать. В связи с этим принято говорить, что объектный файл имеет \emph{двоичное содержимое}.

Не все объектные файлы \emph{переносимые}. Бывают еще \emph{разделяемые}.

Сгенерировать соответствующий \emph{объектный файл} (\verb|*.o|) на базе исходного файла (\verb|*.c|) можно с помощью параметра \verb|-c|
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
$ gcc -c main.c
\end{lstlisting}

Под компиляцией зачастую имеют в виду первые три этапа, а не только второй. Иногда этот термин используется в качестве синонима <<сборки>> и подразумевает все четыре этапа. Например, выражение <<процесс сборки Си>> можно заменить на <<процесс компиляции Си>> \cite[\strbook{90}]{amini-extreme-c:2022}.

\emph{Компиляцию} можно \emph{считать завершенной}, когда получен соответствующий \emph{переносимый объектный файл}. Дальше можно переходить к компиляции других исходников. Можно использовать два флага \verb|-c| и \verb|-o|.

Переносимые объектные файлы \underline{\itshape не являются исполняемыми}! Если конечным продуктом компиляции проекта должен быть исполняемый файл, то нужно взять все переносимые объектные файлы, уже сгенерированные, и скомпоновать их в единое целое.

\subsection{Этап 4. Компоновка}

Чтобы получить еще один объектный файл (на этот раз исполняемый), нужно объединить уже полученные переносимые объектные файлы. Это делается путем \emph{компоновки}.

Наборы инструкций разрабатываются изготовиетлями процессоров, такими как компании Intel и ARM. Кроме того, эти компании создают для своей архитектуры \emph{специальную разновидность ассемблера}.

Программу можно собрать для новой архитектуры, если выполнены два условия \cite[\strbook{91}]{amini-extreme-c:2022}:
\begin{enumerate}
	\item Известная версия ассемблера.
	
	\item Доступна утилита (или программа) от соответствующего производителя, позволяющая скомпилировать \emph{ассемблерный код} в \emph{машинные инструкции}.
\end{enumerate}

Если оба условия выполняются, то мы можем сгенерировать машинные инструкции из исходного кода на Си. И только после того их можно будет сохранить в объектных файлах подходящего формата, например ELF или Mach-O.

Определившись с версией ассемблера, утилитой для компиляции и форматом объектных файлов, можно создать на их основе другие инструменты.

Двумя инструментами, без которых нельзя обойтись при работе с новой архитектурой, являются:
\begin{itemize}
	\item компилятор языка Си,
	
	\item компоновщик.
\end{itemize}

Для работы платформам, аналогичным Unix-подобным опреционным системам, нужны ранее упомянутые инструменты, такие как ассемблер и компоновщик (помните, что их можно использовать отдельно от компилятора).

Компоновщик по умолчанию в Unix-подобных системах -- \verb|ld|. Но применять комповщик в ручную непросто. К счастью, в Unix-подобных системах большинство известных компиляторов сами умеют передавать улитите \verb|ld| подходящие параметры и указывать дополнительные объектные файлы. Поэтому нам не нужно использовать ее.

Вот более простой способ создать исполняемый файл
\begin{lstlisting}[
style = bash,
numbers = none
]
# gcc запускается без флагов
$ gcc main.o  # будет сгенерирован исполняемый файл a.out
$ ./a.out
# processing ...
\end{lstlisting}

Препроцессор позволяет модифицировать исходный код до его компиляции. С его помощью можно разделять исходный код, например вынести объявления в заголовочные файлы и затем подключать их к разным исхдоникам.

Необходимо помнить: \emph{препроцессор} не имеет никакого представления о языке Си и потому не в состоянии найти какие-либо синтаксические ошибки. Вместо этого он выполняет относительно простые операции, которые в основном заключаются \emph{в замене текста}.

\emph{Препроцессор} выполняет простые задачи -- \emph{копирует} содержимое другого файла или \emph{развертывает макрос}, заменяя текст \cite[\strbook{95}]{amini-extreme-c:2022}.

Ввиду разницы в грамматике \emph{препроцессор} и \emph{компилятор} языка Си использует разные синтаксические анализаторы.

Об особенностях устройства препроцессора GNU C компилятора gcc можно здесь \url{http://www.chiark.greenend.org.uk/doc/cpp-4.3-doc/cppinternals.html} В этом документе описывается как препроцессор анализирует директивы и создает синтаксическое дерево, а также алгоритмы развертывания макросов.

Как уже говорилось, \emph{компилятор} принимает на вход \emph{единицу трансляции}, подготовленную \emph{препроцессором}, и генерирует соответствующие \emph{инструкции ассемблера}. После компиляции множественных исходников на языке Си начинается преобразование сгенерированного \emph{ассемблерного кода} в \emph{переносимые объектные файлы}, которые затем объединяются (возможно, с помощью других объектных файлов) в библиотеку или исполняемую программу; при этом применяются такие инструменты, как ассемблер и компоновщик, входящие в состав платформы.

Одна из сложностей компиляции кода на Си состоит в получении \emph{корректных ассемблерных инструкций}, совместимых с \emph{целевой архитектурой}. Утилита \verb|gcc| позволяет компилировать один и тот же исходник для разных архитектур, таких как ARM, Intel x86, AMD и др. У каждой архитектуры есть \emph{свой набор инструкций процессора} и полная ответственность за генерацию корректного ассемблерного кода для конкретной архитектуры лежит на компиляторе \verb|gcc| (или другом).

Чтобы преодолеть указанные трудности, \verb|gcc| (или любой другой компилятор) разделяет данную задачу на два этапа. Вначале он анализирует \emph{единицу трансляции} и переводит ее в переносимую структуру данных под названием <<\emph{дерево абстрактного синтаксиса}>> (abstract syntax tree, AST); данная структутра не имеет прямого отношения к языку Си. Первый этап не зависит от конкретной платформы и набора поддерживаемых инсьтрукций. Все, что относится к определенной архитектуре, происходит на втором этапе. За первый этап отвечает подкомпонент \emph{интерфейс компилятора} (compiler frontend), а за второй -- \emph{кодогенератор} (compiler backend).

AST можно сгенерировать для любого языка программирования, а не только для Си, поэтому данная структура должна быть достаточно \emph{асбтрактной} и независимой от синтаксиса Си. 

Получив дерево абстрактного синтаксиса, \emph{кодогенератор} может приступать к его оптимизации и последующему созданию \emph{ассемблерного кода для целевой архитектуры}.

\emph{Объектный файлы}, сгенерированные в Linux для 64-битной архитектуры AMD, \emph{могут отличаться} от результатов компиляции той же программы в другой ОС, такой как FreeBSD или macOS, и на том же оборудовании. Это значит, что несмотря на одинаковые машинные инструкции, объектные файлы не могут совпадать ввиду различных форматов, используемых в разных системах.

Иными словами, каждая ОС поддерживает свой двоичный формат (\emph{формат объектных файлов}) для хранения инструкций машинного уровня. Поэтому содержимое объектного файла определяется двумя факторами: архитектурой (аппаратным обеспечением) и операционной системой. Эту комбинацию обычно называют \emph{платформой}.

\emph{Объектные файлы} и, следовательно, \emph{ассемблер}, который их сгенерировал, зависят от платформы \cite[\strbook{100}]{amini-extreme-c:2022}. В Linux используется формат ELF (Executable and Linking Format -- формат исполняемых файлов). Проще говоря, в Linux ассемблер создает ELF-файлы.

Сборка проекта на Си начинается с компиляции всех его исходников в соответствующие переносимые объектные файлы.

Какие продукты (их еще называют \emph{артефактами}) можно сгенерировать в проекте на языке Си:
\begin{itemize}
	\item ряд \emph{исполняемых файлов}, которые в большинстве Unix-подобных операционных систем имеют расширение \verb|*.out|. В Microsoft Windows, как правило, используется расширение \verb|*.exe|,
	
	\item ряд \emph{статических библиотек} с расширением \verb|*.a| (в большинстве Unix-подобных систем) или \verb|*.lib| (в Microsoft Windows),
	
	\item ряд \emph{динамических библиотек} или разделяемых объектных файлов. В Unix-подобных операционных системах они обычно имеют расширение \verb|*.so|, в macOS -- \verb|*.dylib| и в Microsoft Windows -- \verb|*.dll|.
\end{itemize}

\emph{Переносимые объектные файлы} не входят в число этих артефактов. Они представляют собой \emph{промежуточные ресурсы}, которые используеются на этапе компоновки для получения перечисленных выше продуктов; далее они не нужны.

Исполняемые файлы, статические и динамические библиотеки называют \emph{объектными файлами}, поэтому объектные файлы сгенерированные ассемблером в качестве промежуточных ресурсов, лучше называть \emph{переносимыми}.

Исполняемый объектный файл можно запустить как \emph{процесс}. Он должен иметь точку входа, с которой начинается выполнение машинных инструкций.

Статическая библиотека -- не что иное, как \emph{архив} с несколькими \emph{переносимыми объектными файлами внутри}. Статические библиотеки обычно подключаются к другим исполняемым файлам и становятся их частью. Это самый простой и удобный способ инкапсулировать программную логику и использовать ее в дальнейшем.

Для сравнения, статические библиотеки становяться частью итогового исполняемого файла на \emph{этапе компоновки}.

\subsection{Принцип работы компоновщика}

Пусть требуется собрать проект на языке Си, состоящий из 5 исходных файлов, и получить итоговую исполняемую программу. В процессе сборки вы скомпилируете все исходники и получите 5 \emph{переносимых объектных файлов}. Далее для создания исполняемого файла понадобиться \emph{компоновщик}.

Компоновщик объединяет все переносимые объектные файлы вдобавок к указанным статическим библиотекам, чтобы получить готовую программу.

Если не вдаваться в подробности, то объектный файл содержит инструкции машинного уровня, эквивалентные единице трансляции. Однако они храняться не в произвольном порядке, а сгруппированы в так называемые \emph{символы}.

Для просмотра символов, хранящихся в объектном файле, можно воспользоваться утилитой \verb|nm|
\begin{lstlisting}[
style = bash,
numbers = none
]
# символы переносимого объектного файла
$ nm target.o
\end{lstlisting}

Если требуется вывести под каждым символом дизассемблированные машинные инструкции, то можно использовать утилиту \verb|objdump|
\begin{lstlisting}[
style = bash,
numbers = none
]
$ objdump -d target.o
\end{lstlisting}

Компоновщик собирает все символы из разных переносимых объектных файлов в один большой объектный файл, формируя тем самым исполняемую программу.

Пример
\begin{lstlisting}[
title = {\sffamily simple\_header.h},
style = c_cpp,
numbers = none
]
#ifndef SIMPLE_HEADER_H
#define SIMPLE_HEADER_H

// прототипы функций
int add(int, int);
int multiply(int, int);

#endif
\end{lstlisting}

\begin{lstlisting}[
title = {\sffamily add.c},
style = c_cpp,
numbers = none
]
// заголовочные файлы НЕ подключаются!
int add(int x, int y) {
    return x + y;
}
\end{lstlisting}

\begin{lstlisting}[
title = {\sffamily multiply.c},
style = c_cpp,
numbers = none
]
// заголовочные файлы НЕ подключаются!
int multiply(int x, int y) {
    return x * y;
}
\end{lstlisting}

\begin{lstlisting}[
title = {\sffamily main.c},
style = c_cpp,
numbers = none
]
#include "simple_header.h"

int main(int argc, char** argv) {
    int x = add(4, 5);
    int y = multiply(x, 10);
}
\end{lstlisting}

Функция \verb|main| ничего не знает об определениях \verb|add| и \verb|multiply|. Вопрос: каким образом она их находит, если в ней не указаны никакие другие исходные файлы? Ответ: \emph{компоновщик} собирает вместе все необходимые \emph{определения} \underline{из разных объектных файлов}; таким образом, код, написанный в функции \verb|main|, может обращаться к коду других функций \cite[\strbook{107}]{amini-extreme-c:2022}.

Выведем символы
\begin{lstlisting}[
style = bash,
numbers = none
]
$ nm main.o
                 U _add # компилятор не нашел определения
0000000000000000 T _main
                 U _multiply # компилятор не нашел определения
\end{lstlisting}

Скомпоновать полученные объектные файлы можно так
\begin{lstlisting}[
style = bash,
numbers = none
]
$ gcc main.o add.o multiply.o  # будет получен исполняемый файл a.out
\end{lstlisting}

\emph{Регистры} -- участки центрального процессора, к которым можно \underline{\itshape быстро} обращаться. Прежде чем выполнять вычисления, значения лучше переместить из \emph{основной памяти} в \emph{регистры} -- это обеспечит высокую эффективность \cite[\strbook{114}]{amini-extreme-c:2022}.

\section{Объектные файлы}

Следует отметить, что \emph{переносимые объектные файлы} считаются \emph{промежуточными} ресурсами; это ингридиенты для другого рода продуктов, которые являются конечными.

\subsection{Двоичный интерфейс приложений}

Если \emph{программный интерфейс приложения} API (Application Programming Interface) обеспечивает совместимость двух программных компонентов с точки зрения их функционального взаимодейтсвия, то \emph{двоичный интерфейс приложений} ABI (Application Binary Interface) гарантирует, что \emph{две программы} и их соответствующие \emph{объектные файлы} совместимы на \emph{уровне машинных инструкций}.

Например, программа не может использовать динамические или статические библиотеки с другими ABI. Что еще хуже, \emph{исполняемый файл} (которые, в сущности, является \emph{объектным}) нельзя запустить в опреационной системе, поддреживающей другой ABI.

ABI обычно содержит следующую информацию:
\begin{itemize}
	\item набор инструкций целевой архитектуры, включая инструкции процессора, структуры памяти, порядок следования байтов, регистры и т.д.
	
	\item существующие типы данных, их размеры и правила выравнивания,
	
	\item соглашение о вызове функций, включая такие подробности, как структура \emph{стекового фрейма} и порядок размещения аргументов в стеке,
	
	\item механизм \emph{системных вызовов} в Unix-подобных ОС,
	
	\item используемые форматы \emph{объектных файлов}, включая \emph{переносимые}, \emph{исполняемые} и \emph{разделяемые}.
\end{itemize}

\subsection{Форматы объектных файлов}

На каждой платформе для хранения машинных инструкций используется свой формат объектных файлов. Речь здесь идет о структуре самих файлов, а не о наборе инструкций, которые поддерживает архитектура. Два отдельных аспекта ABI: формат объектных файлов и набор инструкций архитектуры.

Форматы объектных файлов в разных операционных системах:
\begin{itemize}
	\item ELF применяется в Linux и многих других Unix-подобных ОС,
	
	\item Mach-O ипользуется в системах OS X (macOS и iOS),
	
	\item PE применяется в Microsoft Windows.
\end{itemize}

Название \verb|a.out| расшифровывается как assembler output. Несмотря на то что этот формат уже устарел, его название до сих пор используется по умолчанию в качестве имени \emph{исполняемых файлов}, которые генерирует большинство \emph{компоновщиков}.

ELF -- стандартный формат объектных файлов для Linux и большинства Unix-подобных операционных систем. На самом деле он входит в состав System V ABI и активно применяется в большинстве систем семейства Linux.

Это значит, что один и тот же объектный файл ELF, созданный для одной операционной системы, можно запускать в другой (при условии, что используется та же архитектура). У ELF, как и у любого другого \emph{формата файлов}, есть структура.

В переносимом объектом файле, полученном из скомпилированной единицы трансляции, можно найти следующие элементы:
\begin{itemize}
	\item инструкции машинного уровня, сгенерированные из функций, найденных в единице трасляции (код),
	
	\item значения инициализированных глобальных переменных, объявленных в единице трансляции (данные),
	
	\item \emph{таблицу символов}, содержащую все символы, которые были объявлены и на которые ссылается единица трансляции.
\end{itemize}

Это ключевые элементы, которые можно встретить в любом \emph{переносимом объектном файле}. Конечно, то, как эти элементы структурированы, зависит от конкретного \emph{формата}.

На Linux переносимые объектные файлы можно прочитать с помощью, например, \verb|readelf|. На MacOS X можно воспользоваться утилитой \verb|otool|
\begin{lstlisting}[
style = bash,
numbers = none
]
$ otool -l main.o
\end{lstlisting}

\emph{Исполняемый объектный файл} это один из \emph{конечных продуктов} (артефактов) компиляции проекта на языке Си. Они содержат те же элементы, что и их переносимые аналоги: машинные инструкции, значения для инициализированных глобальных переменных и таблицу символов. Отличается только расположение этих элементов.

Скомпоновать исполняемый объектный файл можно так
\begin{lstlisting}[
style = bash,
numbers = none
]
$ gcc funcs.o main.o -o ex3_1.out
\end{lstlisting}

Статическая библиотека в Unix -- обычный \underline{архив} с \emph{переносимыми объектными файлами}. Сами по себе статические библиотеки не являются объектными файлами. Они скорее служат их \emph{контейнерами}. Иными словами, это не ELF-файлы в Linux и не Mach-O-файлы в macOS. Это просто \emph{архивы}, созданные Unix-утилитой \verb|ar|.

Перед компоновкой из \emph{статической библиотеки} извлекаются \emph{переносимые объектные файлы}. Затем компоновщик ищет в них неопределенные символы и пытается их разрешить.

Создадим статическую библиотеку для проекта на C/C++ с несколькими исходными файлами. Вначале нужно создать \emph{переносимые объектные файлы}, скомпилировав все исходники.

В системах Unix применительно к статическим библиотекам действует общепринятое соглашение об именовании. Имя файла должно начинаться с \verb|lib| и иметь расширение \verb|*.a|. В разных операционных системах могут действовать разные правила; например, в Microsoft Windows статические библиотеки имеют расширение \verb|*.lib|.

Представьте гипотетический проект на языке Си с исходными файлами вида \verb|aa.c|, \verb|bb.c| и вплоть до \verb|zz.c|. Чтобы сгенерировать из них \emph{переносимые объектные файлы}, их нужно скомпилировать так
\begin{lstlisting}[
style = bash,
numbers = none
]
gcc -c aa.c -c aa.o
gcc -c bb.c -c bb.o
...
\end{lstlisting}

В результате выполнения этих команд мы получим нужные нам переносимые объектные файлы. Сборку можно существенно ускорить за счет мощного компьютера и параллельной компиляции.

Для создания \emph{статической библиотеки} достаточно выполнять команду
\begin{lstlisting}[
style = bash,
numbers = none
]
$ ar crs libexample.a aa.o bb.o ... zz.o
\end{lstlisting}

В итоге получится архив \verb|libexample.a| со всеми переносимыми объектными файлами, созданными ранее.

Еще раз, чтобы создать \emph{статическую библиотеку} прежде всего нужно \emph{скомпилировать} \emph{исходные файлы} в соответствующие \emph{переносимые объектные файлы}. Следует отметить, что если в проекте нет функции \verb|main|, то скомпоновать результаты компиляции в исполняемый файл не получиться \cite[\strbook{134}]{amini-extreme-c:2022}.

Поэтому \emph{переносимые объектные файлы} можно либо оставить как есть, либо объединить в статическую библиотеку.

Теперь можно создать \emph{статическую библиотеку} из \emph{переносимых объектных файлов}
\begin{lstlisting}[
title = {\sffamily Создание \emph{статической библиотеки} из \emph{переносимых объектных файлов}},
style = bash,
numbers = none
]
# будет создан файл libgeometry.a (обычный архив)
$ ar crs libgeometry.a geom2d.o geom2d_2.o geom3d.o  
$ mkdir -p /opt/geometry
$ mv libgeometry.a /opt/geometry
\end{lstlisting}

Если передать команде \verb|ar| параметр \verb|t|, можно посмотреть содержимое архива
\begin{lstlisting}[
style = bash,
numbers = none
]
# статическая библиотека состоит из 3 переносимых объектных файлов
$ ar t /opt/geometry/libgeometry.a
geom2d.o
geom2d_2.o
geom3d.o
\end{lstlisting}

Объявления нужны на этапе компиляции, ведь компилятору нужно знать о существовании типов, сигнатур функций и т.д. Для этого используются заголовочные файлы. При работе со статическими библиотеками в языке Си необходим доступ к предоставляемым ими \emph{объявлениям}. Они известны как \emph{публичный интерфейс} (чаще можно встретить называние API).

\emph{API} в языке Си (интерфейсы, предоставляемые библиотекой) обычно представлены в виде \emph{набора заголовков}. Поэтому для написания новой программы, которая использует наши геометрические функции, достаточно иметь заголовчный файл и статическую библиотеку \verb|libgeometry.a|.

Для использования статической библиотеки нужно написать еще один исходный файл, который будет подключать ее API и вызывать ее функции.
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
#include <stdio.h>
#include "geom.h"  // API нашей библиотеки libgeometry.a

int main(int argc, char** argv) {
    cartesian_pos_2d_t cartesian_pos; // объявляем структурную переменную
    cartesian_pos.x = 100;
    cartesian_pos.y = 200;
    
    polar_pos_2d_t = polar_pos = convert_to_2d_polar_pos(&cartesian_pos);
    printf("Polar Position: Length: %f, Theta: %f (deg)\n", polar_pos.length, polar_pos.theta);
}
\end{lstlisting}

Следующая команда завершит сборку, выполнив компоновку и создав исполняемый объектный файл \verb|ex3_3.out|; предполагается, что файл \verb|libgeometry.a| находится в каталоге \verb|/opt/geometry|
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
$ gcc main.o -L/opt/geometry -lgeometry -lm -o ex3_3.out
\end{lstlisting}

Рассмотрим каждый параметр этой команды:
\begin{itemize}
	\item Параметр \verb|-L/opt/geometery| сообщает компилятору \verb|gcc|, что каталог \verb|/opt/geometry| входит в число тех мест, в которых можно найти \emph{статические} и \emph{разделяемые библиотеки}. По умолчанию компоновщик ищет библиотечные файлы в традиционных каталогах, таких как \verb|/usr/lib| или \verb|/usr/local/lib|. Если не указать параметр \verb|-L|, то компоновщик выполнит поиск только по этим стандартным путям.
	
	\item Параметр \verb|-lgeometry| говорят компилятору \verb|gcc|, что ему нужно искать файл \verb|libgeometry.a| или \verb|libgeometry.so|. Если передать параметр \verb|-lxyz|, nо компоновщик будет искать в заданных и стандартных каталогах файл \verb|libxyz.a| или \verb|libxyz.so|. 
	
	\item Параметр \verb|-lm| собщает компилятору \verb|gcc|, что нужно искать еще одну библиотеку с именем \verb|libm.a| или \verb|libm.so|. Она хранит определения математических функций.
	
	\item Параметр \verb|-o ex3_3.out| говорит компилятору \verb|gcc|, что итоговый исполняемый файл должен называться \verb|ex3_3.out|.
\end{itemize}

Если все пройдет гладко, то после выполнения представленной выше команды у вас получится \emph{исполняемый двоичный файл}, который содержит все \emph{переносимые объектные файлы}, найденные в статической библиотеке \verb|libgeometry.a| (по сути архив переносимых объектных файлов), плюс \verb|main.o|.

После компоновки программа не будет зависеть от наличия статических библиотек, поскольку все их содержимое \emph{встраивается} в ее \emph{исполняемый файл}. Иными словами, \emph{полученная программа} является \emph{самостоятельной} и для ее запуска не требуется присутствия статической библиотеки \cite[\strbook{137}]{amini-extreme-c:2022}.

Однако исполняемые файлы, полученные путем компоновки \emph{большого количества статических библиотек}, обычно отличаются \emph{огромными размерами}. Чем больше статических библиотек и переносимых объектных файлов у них внутри, тем крупнее программа. Иногда итоговый размер может достигать сотен мегабайт или даже нескольких гигабайтов.

\emph{Динамаические} (они же \emph{разделяемые}) библиотеки -- еще один продукт компиляции с возможнотью повторного использования. От статических библиотек они отличаются тем, что \underline{\itshape не входят} \underline{\itshape в состав итогового исполняемого файла}. Вместо этого их \emph{необходимо загружать и подключать во время запуска процесса}.

В \emph{динамических} библиотеках неопределенные символы \emph{могут оставаться и после работы компоновщика}; их поиск начинается в момент, когда программа готовится к \emph{загрузке} и \emph{выполнению}. 

Во время загрузки исполняемого файла и его подготовки к выполнению в виде процесса используется \emph{динамический компоновщик}, или просто \emph{загрузчик}.

Перед самим запуском процесса \emph{разделяемый объектный файл} загружается в участок памяти, доступный этому процессу. Данная процедура выполняется динамическим компоновщиком (или загрузчиком), который загружает и выполняет программу.

Скомпилируем тот же исходный код, чтобы получить из него разделяемый объектный файл.
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
$ gcc -c geom2d.c -fPIC -o geom2d.o
$ gcc -c geom3d.c -fPIC -o geom3d.o
...
\end{lstlisting}

Параметр \verb|-fPIC| обязателен, если требуется создать \emph{динамическую библиотеку} из набора \emph{переносимых объектных файлов} (\verb|*.o|). PIC расшифровывается как \emph{position independent code} (позиционно независимый код). \emph{Позиционная независимость} означает, что \emph{инструкции} внутри \emph{переносимого объектного файла} имеют не фиксированные, а \emph{относительные адреса}; таким образом, в разных процессах они могут находится на рзаных участках памяти. 

Нет никакой гарантии, что динамический компоновщик будет загружать разделяемый объектный файл по одному и тому же адресу для разных процессов. На самом деле загрузчик отображает разделяемый объектный файл в память, и диапазоны адерсов у этих отображений могут различаться. Если бы адреса инструкций были абсолютными, то мы не смогли бы загружать одну и ту же динамическую библиотеку сразу \emph{в несколько участков памяти}, принадлежащих \emph{разным процессам}.

Чтобы создать динамическую библиотеку, нам снова нужно будет воспользоваться компилятором. В отличие от \emph{статической библиотеки}, которая является \underline{\itshape обычными архивом}, \emph{разделяемый объектный файл} остается \emph{объектным} \cite[\strbook{140}]{amini-extreme-c:2022}
\begin{lstlisting}[
title = {\sffamily Создание \emph{динамической библиотеки} из \emph{переносимых объектных файлов}},
style = c_cpp,
numbers = none
]
$ gcc -shared 2d.o 3d.o trigon.o -o libgeometry.so
$ mv libgeometry.so /opt/geometry/
\end{lstlisting}

В первой команде мы передали параметр \verb|-shared|, чтобы \emph{компилятор} создал \emph{разделяемый обектный файл} (\verb|*.so|) из \emph{переносимых} (\verb|*.o|). В результате получилась библиотека под названием \verb|libgeometry.so| (разделяемый объектный файл). 

\remark{
{Статическая библиотека} \underline{\itshape встраивается} в итоговый исполняемый файл (\texttt{*.out}). {Динамическая библиотека} \underline{\itshape НЕ встраивается} в итоговый исполняемый файл (\texttt{*.out}), а загружается во время его запуска \cite[\strbook{141}]{amini-extreme-c:2022}
}

\begin{lstlisting}[
style = bash,
numbers = none
]
$ rm -fv /opt/geometry/libgeometry.a
$ gcc -c main.c -o main.o
$ gcc main.o -L/opt/geometry -lgeometry -lm -o ex3_3.out
\end{lstlisting}

Параметр \verb|-lgeometry| заставляет компилятор найти библиотеку, \emph{статическую} (\verb|*.a|) или \emph{динамическую} (\verb|*.so|), и скомпоновать ее с оставльными объектными файлами. Даже если заданная библиотека существует в двух вариантах, при компоновке программы \verb|gcc| отдает предпочтение \emph{разделяемому объектному файлу} (динамической библиотеке).

ВАЖНО! После компоновки со \emph{статической библиотекой} исполняемый файл (\verb|*.out|) получается \emph{самодостаточным}, поскольку в него копируется все ее содержимое; таким образом, он больше не зависит от ее существования \cite[\strbook{141}]{amini-extreme-c:2022}.

Описаное не относится к \emph{разделяемым объектным файлам} (динамическим библиотекам). При запуске исполняемого файла \verb|ex3_3.out|, полученного компоновкой с разделяемым объектным файлом, мы скорее всего получим ошибку
\begin{lstlisting}[
style = bash,
numbers = none
]
./ex3_3.out: error while loading shared libraries: libgeometry.so: cannot open shared object file: Nu such file or directory
\end{lstlisting}

Загрузчику программы (динамическому компоновщику) не удалось найти \verb|libgeomety.so| по своим стандартным поисковым путям. Поэтому нам нужно добавить к ним каталог \verb|/opt/geometry|, в котором находится файл \verb|libgeometry.so|. Для этого нужно \emph{обновить переменную среды} \verb|LD_LIBRARY_PATH| так, чтобы она указывала на текущий каталог.

Загрузчик проверит значение этой переменной среды и выполнит поиск наобходимых разделяемых библиотек по заданному пути. Следует отметить, что в одной переменной можно указать несколько путей (используя \verb|:| в качестве разделителя)
\begin{lstlisting}[
style = bash,
numbers = none
]
$ export LD_LIBRARY_PATH=/opt/geometry
$ ./ex3_3.out
\end{lstlisting}

Переменные среды часто указывают вместе с запуском программы 
\begin{lstlisting}[
style = bash,
numbers = none
]
LD_LIBRARY_PATH=/opt/geometry ./ex3_3.out
\end{lstlisting}

Компонуя программу с несколькими разделяемыми объектными файлами, мы сообщаем системе о том, что в ходе ее запуска нужно найти и загрузить ряд динамических библиотек. Поэтому при запуске программы загрузчик в первую очередь автоматически ищет эти \emph{разделяемые объектные файлы} и отображает нужные символы в подходящие адреса памяти, доступные процессу. Только после этого процессор начинает выполнять код.

Или можно переместить динамическую библиотеку, например, по пути \verb|/usr/local/lib|. Тогда исполняемый файл можно будет запустить просто как \verb|./ex3_3.out|.

\subsection{Ручная загрузка разделяемых библиотек}

Разделяемые объектные файлы можно загружать и использовать иначе, не задействуя загрузчик (динамический компоновщик), который делает это \emph{автоматически}. Идея в том, что программист загружает динамическую библиотеку вручную непосредственно перед использованием ее \emph{символов} (функций).

\begin{lstlisting}[
title = {\sffamily Ручная загрузка динамической библиотеки},
style = c_cpp,
numbers = none
]
#include <stdio.h>
#include <stdlib.h>
#include <dlfcn.h>

#include "geom.h"

polar_pos_2d_t (*func_ptr)(cartesian_pos_2d_t*);  // указатель на функцию

int main(int argc, char** argv) {
    void* handle = dlopen("/opt/geometry/libgeometry.so", RTLD_LAZY);
    if (!handle) {
        fprintf(stderr, "%s\n", dlerror());
        exit(1);
    }
    
    // dlsym возвращает указатель на функцию
    func_ptr = dlsym(handle, "convert_to_2d_polar_pos");  // поиск символа
    if (!func_ptr) {
        fprintf(stderr, "%s\n", dlerror());
        exit(1);
    }
    
    cartesian_pos_2d_t cartesian_pos;
    cartesian_pos.x = 100;
    cartesian_pos.y = 200;
    polar_pos_2d_t polar_pos = func_ptr(&cartesian_pos);
    printf("Polar Position: Length: %f, Theta: %f (deg)\n", polar_pos.length, polar_pos.theta);
}
\end{lstlisting}

Функции \verb|dlopen()| и \verb|dlsym()|, чтобы \underline{\itshape загрузить} \emph{разделяемый объектный файл} и \underline{\itshape выполнить} в нем поиск \emph{символа} \verb|convert_to_2d_polar_pos|. Функция \verb|dlsym| возвращает указатель, с помощью которого можно вызывать нужную функцию.

Данный метод часто называют \emph{отолженной загрузкой} разделяемых объектных файлов \cite[\strbook{144}]{amini-extreme-c:2022}.

\section{Структура памяти процесса}

В языке Си управление \emph{памятью} \underline{полностью ручное}. Более того, вся ответственность за выделение областей памяти и их освобождение после того, как они больше не нужны, ложиться на программиста.

В высокоуровненвых языках программирования, таких как Java или C\#, управление памятью частично выполняется внутреней платформой языка -- например, Java Virtual Machine (JVM) в случае Java. В таких языках программист занимается лишь выделением памяти, но не ее освобождением. Ресурсы освобождаются автоматически с помощью \emph{сборщика мусора}.

{\color{red}В C/C++ сборщиков мусора нет!}

\subsection{Внутренее устройство памяти процесса}

При каждом запуске исполняемого файла опреационноая система создает новый процесс. Процесс -- активная запущенная программа, которая загружена в память и имеет уникальный иднетификатор (process identifier, PID). ОС полностью контролирует создание и загрузку новых процессов.

Процесс перестает быть активным либо в результате нормального завершения, либо при получении сигнала наподобие \verb|SIGTERM|, \verb|SIGINT| или \verb|SIGKILL|, который в итоге заставляет его прекратить работу. \verb|SIGKILL| останавливает процесс немендленно и принудительно:
\begin{itemize}
	\item \verb|SIGTERM| -- сигнал, запрашивающий завершение; дает возможность процессу подготовиться к выходу,
	
	\item \verb|SIGINT| -- сигнал прерывания, который обычно отправляется активным процессам путем нажтия Ctrl+C,
	
	\item \verb|SIGKILL| -- сигнал немедленного завершения; принудительно закрывает процесс, не давая ему возможности подготовиться.
\end{itemize}

Когда операционная система создает процесс, одно из первых действий, которые она совершает, -- выделяет участок памяти с заранее определенной внутренней структурой.

\emph{Память} типичного процесса делится на несколько частей, которые называются \emph{сегментами}. Каждый из них представляет собой область памяти с определенной задачей, предназначенную для хранения данных конкретного типа. 

Список сегментов активного процесса \cite[\strbook{148}]{amini-extreme-c:2022}:
\begin{itemize}
	\item сегмент неинициализированных данных или BSS (Block Started by symbol -- блок, начинающийся с символа),
	
	\item сегмент данных,
	
	\item текстовый сегмент или сегмент кода,
	
	\item сегмент стека,
	
	\item сегмент кучи.
\end{itemize}

Исполняемый объектный файл и и процесс -- это разные вещи. \emph{Исполняемый объектный файл} содержит \emph{машинные инструкции} и за его создание отвечает компилятор. Но \emph{процесс} -- активная программа, созданная путем запуска исполняемого объектного файла.

Процесс -- динаническая сущность, выполняемая внутри операционной системы, в то время как исполняемый объектный файл -- просто набор данных с подготовленной начальной структуой, и на ее основе создается будущий процесс \cite[\strbook{148}]{amini-extreme-c:2022}.

\emph{Статическая} и \emph{динамическая схемы} размещения в памяти включают определенный набор сегментов. Содержимое статической заранее записывается в исполняемый объектный файл во время компиляции исходного кода. А динамическая схема формируется инструкциями процесса, которые выделяют память для переменных и массивов и изменяют ее в соответствии с логикой программы.

Содержимое \emph{статической памяти} можно предсказать по \emph{исходному коду} или \emph{скомпилированному объектному файлу}. Но с \emph{динамической схемой} все сложнее, поскольку ее можно узнать, \emph{только запустив программу}. Кроме того, при каждом выполнении одной и той же программы \emph{содержимое динамической памяти может меняться}. Иными словами, динамическое содержимое любого процесса уникально, и исследовать нужно, пока он работает.

Инструменты, которые используются для исследования статической памяти, обычно рассчитаны на объектные файлы. Пример
\begin{lstlisting}[
title = {\sffamily simple.c},
style = c_cpp,
numbers = none
]
int main(int argc, char** argv) {
    return 0;
}
\end{lstlisting}

Нужно скомпилировать эту программу, чтобы получить итоговый исполняемый объектный файл
\begin{lstlisting}[
style = bash,
numbers = none
]
$ gcc simple.c -o ex_macos.out
\end{lstlisting}

Исполняемый объектный файл содержит предустановленную статическую схему размещения в памяти. Вывести статическую схему размещения в памяти можно так
\begin{lstlisting}[
style = bash,
numbers = none
]
# просмотр статических сигментов
# размеры в байтах
$ size ./ex_macos.out
__TEXT	__DATA	__OBJC	others	dec	hex
16384	0	0	4294983680	4295000064	100008000
\end{lstlisting}

\subsubsection{Сегмент BSS}

Сегмент BSS (Block Started by symbol; блок, начинающийся с символа) фактически предназначен для хранения либо \emph{неинициализированных}, либо \emph{обнуленных глобальных переменных}.

С архитектурной точки зрения в алгоритмах обычно лучше использовать \emph{локальные переменные}. Слишком большое количество глобальных переменных может увеличить размер двоичного файла. То есть объявление \emph{неинициализированных} или \emph{обнуленных} глобальных переменных увеличивает сегмент BSS \cite[\strbook{152}]{amini-extreme-c:2022}.

Расширим предыдущий пример
\begin{lstlisting}[
title = {\sffamily simple.c},
style = c_cpp,
numbers = none
]
int global_var1;  // неинициализированная глобальная переменная
int global_var2;  // неинициализированная глобальная переменная
int global_var3 = 0;  // обнуленная глобальная переменная

int main(int argc, char** argv) {
    return 0;
}
\end{lstlisting}

Если теперь посмотреть статические сегменты
\begin{lstlisting}[
style = bash,
numbers = none
]
$ size -m ex-macos.out
Segment __PAGEZERO: 4294967296
Segment __TEXT: 16384
	Section __text: 22
	Section __unwind_info: 72
	total 94
Segment __DATA: 16384
	Section __common: 12  # это по сути сегмент BSS
	total 12
	Segment __LINKEDIT: 16384
total 4295016448
\end{lstlisting}

Неинициализированные глобальные переменные по умолчанию \emph{обнуляются}.

\subsubsection{Сегмент Data}

Чтобы продемонстрировать, какого рода содержимое находится в этом сегменте, объявим больше глобальных переменных, но на сей раз инициализируем их с помощью \underline{ненулевых} значений.
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
int global_var1;
int global_var2;
int global_var3 = 0;

double global_var4 = 4.5;
char global_var5 = 'A';

int main(int argc, char** argv) {
    return 0;
}
\end{lstlisting}

Сегмент DATA предназначен для хранения \emph{инициализированных} глобальных переменных с \emph{ненулевыми} значениями.

\subsubsection{Сегмент Text (или сегмент Code)}

В \emph{итоговый исполняеый файл} записываются \emph{инструкции машинного уровня}. Поскольку \emph{все машинные инструкции} программы находятся в \emph{сегменте Text} (или \emph{Code}), он должен находится в исполняемом объектном файле -- а именно, в его статической схеме размещения. 

\emph{Процессор} \underline{извлекает} эти инструкции и \underline{выполняет} их во время работы процесса.

\subsection{Исследование динамической схемы размещения в памяти}

Динамическая схема размещения находится в памяти процесса и существует до тех пор, пока он не завершится. Процедурой запуска исполняемого объектного файла занимается программа под названием <<\emph{загрузчик}>>. Он создает новый процесс и его начальную схему размещения в памяти, которая должна быть динамической. Для этого копируются сегменты, найденные в статической схеме размещения исполняемого объектного файла. Затем к ним добавляется два новых сегмента. И только после этого процесс может приступить к выполнению.

Если коротко, то в памяти активного процесса должно быть 5 сегментов, три из которых \emph{копируются} непосредственно из \underline{\itshape статической схемы размещения} \emph{исполняемого объектного файла}, а остальные два создаются с нуля и называются \emph{стеком} и \emph{кучей}. Последние являются динамическими сегментами и существуют только в период работы процессы. 

\emph{Стек} -- \emph{область памяти}, в которой по умолчанию выделяется память \emph{для переменных}. Стек имеет ограниченный размер, поэтому большие объекты в нем хранить нельзя.

Для сравнения, \emph{куча} -- \emph{более крупная} и \emph{гибкая область памяти}, в которой могут поместиться большие объекты и массивы.

\remark{
Динамическая схема размещения -- не то же самое, что динамическое выделение памяти
}

Пять сегментов, из которых состоит динамическая память (то есть, как я понял, память активного процесса), ссылаются на разные участки основной памяти, уже \emph{выделенные} и доступные \emph{только} соответствующему процессу. Все эти сегменты -- динамические в том смысле, что во время выполнения их содержимое постоянно меняется; исключение составляет только \emph{сегмент Text} (сегмент кода), который является \emph{статическим} и \emph{неизменяемым} в буквальном смысле слова.

{\color{blue} Сегмент BSS, сегмент данных (Data) и сегмент кода (Text/Code) -- это \emph{статическая} схема размещения в памяти, а стек и куча -- это \emph{динамическая} схема размещения в памяти} \cite[\strbook{149}]{amini-extreme-c:2022}

\subsection{Отражение памяти}

Пример
\begin{lstlisting}[
title = {\sffamily sample.c},
style = c_cpp,
numbers = none
]
#include <unistd.h>

int main(int argc, char** argv) {
    while (1) {
        sleep(1);
    };
}
\end{lstlisting}

Компилируем пример (делаем из исходного файла \verb|*.c| исполняемый объектный файл \verb|*.out|)
\begin{lstlisting}[
style = c_cpp,
numbers = none	
]
$ gcc sample.c -o ex.out
\end{lstlisting}

Теперь можно запустить процесс в фоновом режиме
\begin{lstlisting}[
style = bash,
numbers = none
]
$ ./ex.out &
[1] 21881  # PID
\end{lstlisting}

Чтобы завершить процесс, следует воспользоваться командой \verb|kill|
\begin{lstlisting}[
style = bash,
numbers = none
]
$ kill -9 <PID>
\end{lstlisting}

На компьютере под управлением Linux сведения о процессе можно найти в файлах внутри каталога \verb|/proc|. Он находится в специальной файловой системе под названием \emph{procfs}, которая отличаются от обычных ФС тем, что не предназначена собственно для хранения данных; это скорее иерархический интерфейс для получения информации о разных свойствах отдельных процессов или системы в целом.

Файловая система procfs есть не только в Linux. Она обычно является частью Unix-подобных опреционных систем, хотя используют ее не все они. Например, в FreeBSD она применяется, а в macOS -- нет.

Стек обычно имеет ограниченный размер и плохо подходит для хранения крупных объектов. Если в этом сегменте закончиться свободное место, то процесс больше не сможет вызывать функции, поскольку стек активно используется механизмом вызовов. В таких случаях процесс принудительно завершается операционной системой. \emph{Переполнение стека} -- широко известная ошибка, которая возникает при полном заполнении стека. 

Когда объявляется локальная переменная, она создается на \emph{вершине стека}. При выходе из функции компилятор снимает со стека ее локальные переменные, в результате чего на вершину поднимаются значения внешней области видимости.

В стеке хранятся не только переменные. При каждом вызове функции на стек кладется новая запись под названием <<\emph{стековый фрейм}>>. 

Поскольку стек ограничен в размере, в нем рекомендуется объявлять небольшие переменные. Кроме того, не следует создавать слишком много стековых фреймов в результате бесконечной рекурсии или множества вызовов функции.

Куча может достигать десятков гигабайтов. В ней обычно размещают постоянные, глобальные и очень большие объекты, такие как массивы и битовые потоки.

С локальными переменными, созданными на вершине стека, можно взаимодействовать напрямую, тогда как для доступа к содержимому кучи необходимо использовать указатели.

\emph{Статическая схема размешения в памяти} находится в исполняемом объектном файле (\verb|*.out|) и разбита на части, которые называются \emph{сегментами}. В состав статической схемы размещения входят такие сегменты, как Text, Data и BSS \cite[\strbook{169}]{amini-extreme-c:2022}.

Сегмент Text (Code) используется для хранения \emph{инструкций машинного уровня}, предназначенных для выполнения, когда на основе текущего исполняемого файла создается новый процесс.

\section{Стек и куча}

Куча и стек -- основные сегменты, с которыми работает программист. Data, Text и BSS используются реже, и доступ к ним ограничен. Причиному тому факт, что данные сегменты генерируются компилятором и зачастую занимают небольшую долю в общем объеме памяти запущенного процесса. Это не значит, что они важны, но большую часть времени придется работать со стеком и кучей.

Стек и его содержимое тщательно спроектированы для обеспечения бесперебойной работы процесса. \emph{Выделение памяти в стеке} происходит \emph{быстро} и не требует применения никаких специальных функций. Более того, освобождение ресурсов и все действия по управлению памятью происходят \emph{автоматически}.

Стек не очень большой, поэтому в нем нельзя хранить крупные объекты.

Объявление массива, выделенного \emph{на вершине стека}
\begin{lstlisting}[
title = {\sffamily sample.c},
style = c_cpp,
numbers = none
]
#include <string.h>

int main(int argc, char** argv) {
    char arr[4];
    arr[0] = 'A';
    arr[1] = 'B';
    arr[2] = 'C';
    arr[3] = 'D';
}
\end{lstlisting}

Это простая программа и в ней легко разобраться, но в ее памяти происходит нечто интересное. Прежде всего, память, необходимая для массива \verb|arr|, выделяется в \underline{\itshape стеке}, а \emph{не в куче} просто потому, что мы не использовали функцию \verb|malloc| \cite[\strbook{173}]{amini-extreme-c:2022}.

По умолчанию \emph{в стеке} выделяются все \emph{переменные} и \emph{массивы}. Чтобы выделить \emph{место в куче}, необходимо воспользоваться функцией \verb|malloc| или ее аналогом \verb|calloc|. {\color{red}В противном случае память будет выделена \emph{в стеке}, а точнее, на его вершине} \cite[\strbook{173}]{amini-extreme-c:2022}.

Чтобы программу можно было отлаживать, ее двоичный файл должен быть собран соответствующим образом. То есть нам нужно сообщить компилятору о том, что в исполняемом файле должны быть \emph{отладочные символы}.

Скомпилируем описанный выше пример с отладочным параметром \verb|-g|
\begin{lstlisting}[
style = bash,
numbers = none
]
$ gcc -g sample.c -o ex_dbg.out
\end{lstlisting}

Параметр \verb|-g| говорит компилятору о том, что итоговый исполняемый объектный файл должен содержать отладочную информацию. Он влияет на размер программы.

\remark{
По сравнению с другими сегментами \emph{стек} заполняется в обратном порядке. Другие области памяти заполняются, начиная с младшего адреса, но со стеком все не так
}

Можно модфицировать данные, помещенные в стек. Если продолжить выполнение и если была модифицированна важная часть стека, то можно ожидать сбоя; в крайнем случае это изменение будет обнаружено неким механизмом, который прервет  работу программы.

Значения нельзя записывать за рамками переменных и массивов, поскольку в стеке адреса растут в обратном направлении, что повышает вероятность модификации уже записанных байтов.

\subsection{Рекомендации по использованию стековой памяти}

\emph{Каждая переменная} имеет \emph{свою область видимости}, которая определяет ее \emph{время жизни}. Это значит, что вместе с данной областью исчезают и все переменные, которые были в ней созданы.

Кроме того, только переменные, находящиеся в стеке, выделяются и освобождаются автоматически. Автоматическое управление памятью обусловлено природой стекового сегмента.

Любая переменная, которую вы объявляете в стеке, автоматически создается \emph{на его вершине}. Выделение памяти происходит автоматически и может считаться началом жизни переменной. После этого поверх нее будет записано множество других переменных и стековых фреймов. Но пока она находится в стеке и над ней есть другие переменные, ее существование продолжается.

Однако рано или поздно программа должна завершиться, и перед ее выходом стек дложен быть пустым. Поэтому в какой-то момент наша переменная будет извлечена из стека. Таким образом, освобождение ее памяти происходит автоматически и знаменует конец ее жизненного цикла. Вот почему мы говорим, что управление памятью стековых переменных происходит автоматически, без участия программиста.

Пример
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
int main(int argc, char** argv) {
    int a;
    ...
    return 0;
}
\end{lstlisting}

Эта переменная будет оставаться в стеке, пока не завершиться функция \verb|main|. Иными словами, переменная существует, пока остается действительной ее область видимости (функция \verb|main|). И, поскольку в этой функции происходит выполнение всей программы, время жизни данной переменной почти такое же, как у глобального значения, доступного на протяжении всей работы процесса.

Тем не менее \emph{глобальное значение} всегда остается в памяти, даже когда завершаются главная функция и сама программа, в то время как наша переменная будет извлечена из стека. Кроме того, стоит отметить, что что глобальные переменные выделяются в другом сегменте памяти, Data или BSS, который ведет себя не так, как стек \cite[\strbook{180}]{amini-extreme-c:2022}.

Чтобы компилятор gcc считал ошибками любые предупреждения, то передайте ему параметре \verb|-Werror|. То же самое можно сделать и для отдельных предупреждений; например, в случае возвращения адреса локальной переменной, достаточно указать параметр \verb|-Werror=return-local-addr|.

\begin{lstlisting}[
style = c_cpp,
numbers = none
]
int* get_integer() {
    int var = 10;  // объявление переменной на вершине стека
    return &var;
}

int main(int argc, char** argv) {
    int* ptr = get_integer();
    *ptr = 5;
    return 0;
}
\end{lstlisting}

Переменная \verb|var| была локальной для функции \verb|get_integer| и перестала существовать просто потому, что мы уже вышли из функции \verb|get_integer| и соответствующей области видимости. Таким образом, возвращенный указатель получился \emph{висячим}.

Обычно \emph{указатели на переменные} в текущей области видимости рекомендуется передавать \emph{другим функциям}, но не наоборот, поскольку они существуют, пока область видимости остается действительной. Дальнейшие вызовы кладут на стек новые значения, и текущая область видимости не исчезнет раньше них \cite[\strbook{183}]{amini-extreme-c:2022}.

Ключевые характеристики стека \cite[\strbook{183}]{amini-extreme-c:2022}:
\begin{itemize}
	\item стековая память имеет ограниченный размер, поэтому не подходит для хранения крупных объектов,
	
	\item адреса в стеке увеличиваются в обратном порядоке, поэтому, перемещаясь вперед по стеку, мы читаем уже сохраненные байты,
	
	\item управление памятью в стеке происходит автоматически. Это касается как выделения, так и освобождения места,
	
	\item каждая переменная в стеке обладает областью видимости, которая определяет ее время жизни,
	
	\item указатели должны ссылаться только на те стековые переменные, которые все еще находятся в области видимости,
	
	\item освобождение памяти \emph{стековых переменных} происходит автоматически, прямо \emph{перед исчезновением области видимости}, и вы не можете на это повлиять,
	
	\item указатели на переменные, существующие в текущей области видимости, можно передавть в другие функции в качестве аргументов. 
\end{itemize}




\section{Структура программы}

Программ состоит из инструкций, расположенных в текстовом файле
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
<Подключение заголовочных файлов>
<Объявление глобальных переменных>
<Объявление функций и пр.>
int main(void) {
    <Инструкции>
    return 0;
}
<Определения функций и пр.>
\end{lstlisting}

В самом начале программы подключаются \emph{заголовочные файлы}, в которых содержаться \emph{объявления} идентификаторов \underline{без их реализации}.

После подключения файлов производится \emph{объявление глобальных переменных}. \emph{Глобальные переменные} видны во всей программе, включая функции. Если объявить переменную внутри функции, то \emph{область видимости переменной} будет ограничена рамками функции и в других частях программы использовать переменную нельзя. Такие переменные называются \emph{локальными}

При объявлении переменной можно сразу присвоить начальное значение. Присваивание значения переменной при объявлении называется \emph{инициализацией переменной}
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
int x = 10;
int x = 21; int y = 85; int z = 56;
\end{lstlisting}

Если глобальной переменной не присвоено значение при объявлении, то она будет иметь значение 0. Если \emph{локальной} переменной не присвоено значение, то переменная будет содержать {\color{red}произвольное значение}. Как говорят в таком случае: переменная содержит <<мусор>> \cite[\strbook{59}]{prokhorenok-prog-c:2020}.

После директив препроцессора точка с запятой не указывается. В этом случае концом инструкции является конец строки. Директиву препроцессора можно узнать по символу \verb|#| перед названием директивы. 

После объявления глобальных переменных могут располагаться \emph{объявления функций}. Такие объявления называются \emph{прототипами}. Схема прототипа функции выглядит следующим образом
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
<Тип возвращаемого значения> <Название функции>(
    [<Тип> [<Параметр 1>]
    [, ..., <Тип> [<Параметр N>]]]);
\end{lstlisting}

Например, прототип функции, которая складывает два целых числа и возвращает их сумму, выглядит так
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
int sum(int x, int y);
\end{lstlisting}

После объявления функции необходимо описать ее реализацию, которая называется \emph{определением функции}. Определение функции обычно располагается после определения функции \verb|main()|. Обратите внимание на то, что объявлять прототип функции \verb|main()| не нужно.

Пример определения функции \verb|sum()|
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
int sum(int x, int y) {
    return x + y;
}
\end{lstlisting}

Первая строка в определении функции \verb|sum()| совпадает с объявлением функции. Следует заметить, что в объявлении функции можно не указывать названия параметров. Достаточно будет указать информацию о типе данных. Таким образом, объявление функции можно записать так
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
int sum(int, int);
\end{lstlisting}

После объявления функции ставится точка с запятой. Если функция не возвращает никакого значения, то перед названием функции вмето типа данных указывается ключевое слово \verb|void|. Пример объявления функции, которая не возвращает значения
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
void print(int);  // объявление функции; прототип

// определение функции, которая не возвращает значение
void print(int x) {
    printf("%d", x);
}
\end{lstlisting}

Самой главной функцией в программе является функция \verb|main()|. Именно функция с названием \verb|main()| будет автоматически вызываться при запуске программы. Функция имеет три прототипа
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
int main(void);
int main(int argc, char *argv[]);
int main(int argc, char *argv[], char **penv);
\end{lstlisting}

Значение \verb|void| внутри круглых скобок означает, что функция не принимает параметры. Второй прототип применяется для получения значений, указанных при запуске программы из командной строки. Количество значений доступно через параметр \verb|argc|, а сами значения через параметр \verb|argv|. Параметр \verb|penv| в третьем прототипе позволяет получить значения переменных окружения.

Ключевое слово \verb|int| означет, что функция возвращает целое число. Число 0 означает нормальное завершение программы. Если указано другое число, то это свидетельствует о некорретном завершении программы. Согласно стандрату, внутри функции \verb|main()| ключевое слово \verb|return| можно не указывать. В этом случае компилятор должен самостоятельно вставить инструкцию, возвращающую значение 0. Возвращаемое значение передается операционной системе и может использоваться для определения корректности завершения программы.

Вместо безликого значения 0 можно воспользоваться макроопределением \verb|EXIT_SUCCESS|, а для индикации некорректного завершения программы -- макроопределением \verb|EXIT_FAILURE|. Предварительно необходимо включить заголовочный файл \verb|stdlib.h|.

Пример программы
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
// Включение заголовочных файлов
#include <stdio.h>
#include <stdlib.h>

// Объявление глобальных переменных
int x = 21;
int y = 85;

// Объявление функций и пр.
int sum(int, int);
void print(int);

// Главная функция (точка входа в программу)
int main(void) {
    int z;
    z = sum(x, y);
    print(z);
    return EXIT_SUCCESS;
}

// Определение функций
int sum(int x, int y) {
    return x + y;
}

void print(int x) {
    printf("%d", x);
}
\end{lstlisting}

Объявление функций можно вынести в отдельный заголовочный файл и включить его с помощью директивы \verb|#include|
\begin{lstlisting}[
title = {\sffamily MyPrototypes.h},
style = c_cpp,
numbers = none
]
#ifndef MYPROTOTYPES_H_
#define MYPROTOTYPES_H_

// Объявление функций и пр.
int sum(int x, int y);

#endif /* MYPROTOTYPES_H_ */
\end{lstlisting}

Директивы препроцессора \verb|#ifndef|, \verb|#define| и \verb|#endif| препятствуют повторному включению заголовочного файла. Вместо этих директив можно указать в самом начале файла директиву препроцессора \verb|#pragma| со значением \verb|once|, то есть
\begin{lstlisting}[
title = {\sffamily MyPrototypes.h},
style = c_cpp,
numbers = none
]
#pragma once

// Объявление функций и пр.
int sum(int x, int y);
\end{lstlisting}

\section{Ввод / вывод}

\subsection{Вывод данных}

Для вывода одиночного символа в языке Си применяется функция \verb*|putchar()|: \verb|putchar('w');| Вывести строку позволяет функция \verb*|puts()|, которая выводит строку и вставляет символ перевода строки: \verb|puts("String);|.

Для форматированного выводв используется функция \verb*|printf()|. Можно также воспользоваться функцией \verb|_printf_l()|, которая позволяет дополнительно задать локаль. Функции \verb*|printf()| можно передавать обычные символы и спецификаторы формата, начинающиеся с символа \verb|%|
\begin{lstlisting}[
style = c_cpp,
numbers = none	
]
printf("String\n");
printf("Count %d\n", 10);  // спецификатор формата %d
printf("%s %d\n", "Count", 10);  // спецификаторы формат %s и %d
\end{lstlisting}

NB: \emph{Тип данных} переданных \emph{значений} \underline{должен совпадать} с \emph{типом спецификатора}. Если, например, в качестве значения для спецификатора \verb*|%s| указать число, то это приведет к ошибке времени выполнения.

Спецификаторы имеют следующий синтаксис \cite[\strbook{66}]{prokhorenok-prog-c:2020}
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
%[<Флаги>][<Ширина]>[.<Точность>][<Размер>]<Тип>
\end{lstlisting}

В параметре \verb|<Тип>| могут быть указаны следующие символы:
\begin{itemize}
	\item \verb*|c| -- символ: \verb|printf("%c", 'w');|
	
	\item \verb*|s| -- строка: \verb|printf("%s", "String");|
	
	\item \verb*|d| или \verb|i| -- десятичное целое со знаком: \verb|printf("%d %i", 10, 30);|
	
	\item \verb|u| -- десятичное целое без знака: \verb|printf("%u", 10);|
	
	\item \verb|o| -- восмеричное число без знака: \verb|printf("%#o %#o", 10, 77);|
	
	\item \verb|x| -- шестнадцатиричное число без знака в нижнем регистре: \verb|printf("%#x %#x", 10, 0xff);|
	
	\item \verb|f| -- вещественное число в десятичном представлении: \verb|printf("%#.0f %.0f", 100.0, 100.0);|
	
	\item \verb*|e| -- вещественное число в экспоненциальной форме: \verb|printf("%e", 18657.81452);|
	
	\item \verb|g| -- эквивалентно \verb*|f| или \verb|e| (выбирается более короткая запись числа):\\ \verb|printf("%g %g %g", 0.086578, 0.000086578, 1.865E-05);|
	
	\item \verb|p| -- вывод адреса переменной: \verb|printf("%p", &x);|
	
	\item \verb*|%| -- символ процента: \verb|printf("10%%");|
\end{itemize}

Параметр \verb|<Ширина>| задает минимальную ширину поля. Если строка меньше ширины поля, то она дополняется пробелами. Если строка не помещается в указанную ширину, то значение игнорируется и строка выводится полностью:
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
printf("'%3s", "string"); // 'string'
printf("%10s", "string"); // '    string'
\end{lstlisting}

Параметр \verb*|<Точность>| задает количество знаков после точки для вещественных чисел. Перед этим параметром обязательно должна стоять точка. Пример
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
printf("'%10.5f'", 3.1445454545);  // '   3.14454'
printf("'%.3f'", 3.1434534545);  // '3.143'
\end{lstlisting}

Вместо минимальной ширины и точности можно указывать символ \verb*|*|. В этом случае значения передаются через параметры функции \verb*|printf()| в порядке указания символов в строке формата.

В параметре \verb|<Флаги>| могут быть указаны следующие символы:
\begin{itemize}
	\item \verb*|#| -- для восьмиричных значений добавляет в начало символ 0, для шестнадцатиричных значений добавляет комбинацию символов \verb|0x| (если используется тип \verb*|x|) или \verb|0X| (если используется тип \verb*|X|), для вещественных чисел указывает всегда выводить дробную точку, даже если задано значение 0 в параметре \verb|<Точность>|.
	
	\item \verb*|0| -- задает наличие ведущих нулей для числового значения,
	
	\item \verb|-| -- задает выравнивание по левой границе области. По умолчанию используется выравнивание по правой границе: \verb|printf("'%-5d'", 3);|
	
	\item \verb|пробел| -- вставляет пробел перед положительным числом. Перед отрицательным числом будет стоять минус.
	
	\item \verb*|+| -- задает обязательный вывод знака как для отрицательных, так и для положительных чисел.
\end{itemize}

\subsection{Ввод данных}

Для ввода одного символа предназначена функция \verb*|getchar()|. В качестве значения фукнция возвращает код введенного символа.

Для получения и \emph{автоматического преобразования данных в конкретный тип} (например, в целое число) предназначена функция \verb*|scanf()|. При вводе строки функция не производит никакой проверки длины строки, что может привести к переполнению буфера. Функция возвращает количество произведенных присваиваний.

NB: Чтобы избежать переполнения буфера, обязательно указываейте \emph{ширину} при использовании спецификатора \verb*|%s| (например, \verb|%255s|).

\begin{lstlisting}[
style = c_cpp,
numbers = none
]
int x = 0;

printf("Enter number: ");
fflush(stdout);
fflush(stdin);

int status = scanf("%d", &x);  // &x -- адрес переменной 'x', а не ее значение!
if (status == 1) {
    printf("You entered: %d\n", x);
} else {
    puts("Error!);
}

printf("status = %d\n", status);
\end{lstlisting}

То есть конструкция в языке Си
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
float x = 0.0;
printf("Enter number: ");
scanf("%f", &x);  // адрес переменной x
\end{lstlisting}
это то же самое, что в Python конструкция
\begin{lstlisting}[
style = ironpython,
numbers = none
]
x = float(input("Enter number: "))
\end{lstlisting}

Если ожидается строка, то символ \verb*|&| указывать не следует, так как имя переменной в случае строки это ссылка на первый элемент массива символов
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
char word[255] = "";
printf("Enter word: ");
fflush(stdout);  // сброс буфера вывода в консоль
fflush(stdin);  // очистка буфера ввода
// пользовательский ввод будет обрезан до 255 символов
scanf("%255s", word);  // %255s чтобы избежать переполнения буфера

printf("You entered: %s", word);
\end{lstlisting}

Функция \verb|fflush(stdout)| сбрасывает данные из буфера потока вывода \verb*|stdout| в консоль. Если \emph{буфер вывода} принудительно не сбросить, пользователь может не увидеть подсказку вообще \cite[\strbook{74}]{prokhorenok-prog-c:2020}.

Функция \verb*|fflush(stdin)| очищает буфер потока ввода \verb|stdin|. Если не очистить \emph{буфер ввода} перед повторным получением числа, то это число может быть получено из предыдущего ввода из буфера. Например, при запросе первого числа было введено значение \verb*|"47 3"|. Функция \verb|scanf()| получит число 47, а второе число оставит в буфере, и оно будет доступно для следующей операции ввода. 

Для ввода строки предназначена функция {\color{red}\verb*|gets()|, НО применять ее в программе не следует}, так как функция не производит никакой проверки длины строки, что может привести к переполнению буфера.

Лучше получать строку посимвольно с помощью функции \verb*|getchar()| или воспользоваться функцией \verb|fgets()|.

\emph{Строки} в языке Си представляют собой последовательность (\emph{массив}) \emph{символов}, последним элементом которого является \emph{нулевой символ} (\verb*|'\0|). 

Пример указателя
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
char *p = NULL;
\end{lstlisting}

То, что переменная \verb|p| является указателем, говорит символ \verb*|*| перед ее именем при объявлении. \emph{Значением указателя} является \emph{адрес данных} в \emph{памяти} компьютера. Указатель, которому присвоено значение \verb|NULL|, называется \emph{нулевым указателем}. Такой указатель ни на что не указывает, пока ему не будет присвоен адрес.

Размер массива символов и длина строка -- это разные вещи. Размер массива -- это общее количество символов. которое может хранить массив. Длина строки -- это количество символом внутри символьного массива до первого нулевого символа.
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
char buf[256] = "abc";  // массив символов
printf("%s\n", buf);  // abc
printf("%d\n", (int)sizeof(buf));  // 256
printf("%d\n", (int)strlen(buf));  // 3
\end{lstlisting}

Здесь \verb*|(int)sizeof(buf)| приводит результат вычисления \verb|sizeof(buf)| к целочисленному типу.

Функция \verb*|getchar()| позволяет получить символ только после нажатия клавиши \verb|<Enter>|. Если необходимо получить символ сразу после нажатия клавиши на клавиатуре, то можно воспользоваться функциями \verb*|_getche()| и \verb|_getch()|.

Функция \verb*|_getche()| возвращает код символа и выводит его на экран. При нажатии клавиши функция \verb|_getch()| возвращает код символа, но сам символ на экран не выводится. Это обстоятельство позволяет использовать функцию \verb*|_getch()| для получения конфиденциальных данных.

\subsubsection{Получение данных из командной строки}

Передать данные можно в командной строке после названия файла. Для получения данных в программе используется следующий формат функции \verb|main()|
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
int main(int argc, char *argv[]) {
    // Инструкции
    return 0;
}
\end{lstlisting}

Параметр \verb|argc| -- \emph{количество аргументов}, переданных в комадной строке. Следует учитывать, что первым аргументом является название исполняемого файла, поэтому значение параметра \verb*|argc| не может быть меньше единицы. Через второй параметр \verb*|argv| доступны \emph{все аргументы в виде строки} (тип \verb|char *|). Квадратные скобки после названия второго параметра означают, что доступен массив строк.

Чтобы окно программы сразу не закрывалось следует использовать функцию \verb|getchar()|
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
#include <stdio.h>
#include <stdlib.h>

int main(void) {
    printf("Process ...\n");
    printf("Press key\n");
    fflush(stdout);  // сбросить буфер вывода в консоль
    fflush(stdin);  // очистить буфер ввода
    getchar();  // приостанавливает закрытие окна программы
    return 0;
}
\end{lstlisting}

\subsubsection{Преждевременное завершение программы}

Для того чтобы прервать выполнение программы дострочно можно использовать функцию \verb*|exit()|. В качестве параметра функция принимает число, которое является \emph{статусом завершения}. Число 0 означает \emph{нормальное завершение} программы, а любое другое число -- некорректное завершение. Эти числа передаются операционной системе.

Вместо чисел можно использовать макроопределения \verb|EXIT_SUCCESS| (нормальное завершение) и \verb*|EXIT_FAILURE| (аварийное завершение). Пример
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
exit(EXIT_FAILURE);  // То же что exit(1);
\end{lstlisting}



\section{Переменные и типы данных}

\emph{Переменные} -- это участки памяти, используемые программой для хранения данных. Прежде чем использовать переменную, ее необходимо предварительно \emph{объявить} глобально (вне функции) или локально (внутри функции). В большинстве случаев \emph{объявление переменной} является сразу и ее \emph{определением}.

При использовании старых компиляторов все локальные переменные должны быть объявлены в самом начале функции.

Каждая переменная должна иметь уникальное имя. Регистр бука имеет значение.

В языке Си доступны следующие элементарные типы данных:
\begin{itemize}
	\item \verb*|_Bool| -- логический тип данных. Может содержать значения <<Истина>> (соответствует числу~1) или <<Ложь>> (соответсвует числу 0)
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
_Bool is_int = 1;
printf("%d\n", is_int);  // 1
printf("%d\n", !is_int);  // 0
\end{lstlisting}

В языке Си нет ключевых слов \verb|true| и \verb|false|. Вместо них используеются числа 1 и 0 соответственно. Любое число, отличное от нуля, ялвяется истиной, а число, равно нулю, -- ложью. Если требуется объявлять логические переменные так же как в языке C++, можно подключить заголовочный файл \verb|stdbool.h|, в котором определены макросы \verb*|bool|, \verb*|true| и \verb|false|.

\item \verb*|char| -- код символа. Занимает 1 байт. Пример:
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
char ch = 'w';
printf("%c\n", ch);  // выводим символ w
printf("%d\n", ch);  // выводим код символа
printf("%d\n", (int)sizeof(char));  // размер в байтах
\end{lstlisting}

\item \verb|int| -- целое число со знаком.

\item \verb*|float| -- вещественное число. Занимает 4 байта.

\item \verb*|double| -- вещественное чило двойной точности. Занимает 8 байт.

\item \verb|void| -- означает отсутствие типа. Используется в основном для того, чтобы указать, что функция \emph{не возвращает никакого значения} или \emph{не принимает параметров}, а также для \emph{передачи} в функцию \emph{данных произвольного типа}.
\end{itemize}

Перед элементарным типом данных могут быть указаны следующие \emph{модификаторы} или их комбинация:
\begin{itemize}
	\item \verb*|signed| -- указывает, что \emph{символьный} или \emph{целочисленный типы} могут содержать отрицательные значения. Тип \verb*|signed int| (или просто \verb|signed|) соответствует типу \verb*|int|.
	
	\item \verb|unsigned| -- указывает, что \emph{символьный} или \emph{целочисленный типы} \underline{не могут} содержать \emph{отрицательные} значения.
	
	\item \verb|short| -- может быть указан перед целочисленным типом. Занимает 2 байта.
	
	\item \verb*|long| -- может быть указан перед целочисленным типом и типом \verb|double|.
\end{itemize}

При использовании модификаторов тип \verb|int| подразумевается по умолчанию, поэтому тип \verb*|int| можно не указывать.

Если переменная может изменять свое значение извне, то перед модификатором указывается ключевое слово \verb|volatile|. Это ключевое слово предотвращает проведение оптимизации программы, при котором предполагается, что значение переменной может быть изменено только в программе.

Вместо указания конкретного целочисленного типа можно воспользоваться макроопределениями \verb*|__int8|, \verb|__int16|, \verb*|__int32| и \verb|__int64|. В заголовочном файле \verb*|stdint.h| объявлены знаковые типы фиксированной длины \verb|int8_t|, \verb*|int16_t|, \verb|int32_t| и \verb*|int64_t|, а также беззнаковые \verb|unit8_t|, \verb*|unit16_t|, \verb|unit32_t| и \verb*|uint64_t|.

После \emph{объявления переменной} под нее \emph{выделяется} определенная \emph{память}, размер которой зависит от используемого типа данных и разрядности операционной системы \cite[\strbook{99}]{prokhorenok-prog-c:2020}. 

Оператор \verb*|sizeof|, например в \verb|(int)sizeof(x)| возвращает значение типа \verb|size_t|. При объявлении переменной ей можно сразу присвоить начальное значение, указав его после опреатора \verb*|=|. Переменная становится видимой сразу после объявления, поэтому на одной строке с объявлением (после запятой) эту переменную уже можно использовать для инициализации других переменных.

\emph{Локальные} (объявленные внутри функции) переменные инициализируются \emph{при каждом вызове функции}, а \emph{статические} (сохраняющие свое значение между вызовами) \emph{локальные переменные} -- один раз при первом вызове \cite[\strbook{100}]{prokhorenok-prog-c:2020}.

Оператор \verb*|typedef| позволяет создать псевдоним для существующего типа данных. В дальнейшем псевдоним можно указывать при объявлении переменной. 

Оператор имеет следующий формат
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
typedef long int lint;
lint x = 5L, y = 10L;
\end{lstlisting}

После создания псевдонима его имя можно использовать при создании другого псевдонима. Псевдонимы предназначены для создания машинно-независимых программ. Например тип данных \verb|size_t| является пседонимом, а не новым типом.

Константны -- это участки памяти, значения в которых не должны изменяться во время работы программы.

\subsection{Спецификаторы хранения}

Перед модификатором и типом могут быть указаны следующие \emph{спецификаторы хранения} \cite[\strbook{104}]{prokhorenok-prog-c:2020}:
\begin{itemize}
	\item \verb*|auto| -- локальная переменная создаетчя при входе в блок и удаляется при выходе из блока. Так как локальные переменные по умолчанию \emph{автоматические}, ключевое слово \verb|auto| в языке Си практически не используется.
	
	\item \verb*|register| -- является подсказкой компилятору, что переменная будет использоваться \emph{интенсивно}. Для ускорения досутпа значения такой переменной сохраняется в \emph{регистрах процессора}. Компилятор \emph{может проигнорировать} это объявление и сохранить значение \emph{в памяти}. Ключевое слово может использоваться при объявлении переменной внутри блока или в параметрах функции. К глобальным переменным не применяется.
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
register int x = 10;
\end{lstlisting}
    \item \verb|extern| -- сообщает компилятору, что переменная определена \underline{в другом месте}, например, в другом файле. Ключевое слово лишь \emph{объявляет} переменную, а \emph{не определяет} ее. Таким образом, \emph{память} под переменную \emph{повторно не выделяется}. Если при объявлении переменной производится инициализация переменной, то \emph{объявление}  становится \emph{определением переменной}
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
#include <stdio.h>

int main(void) {
    extern int x;        // Определена в другом месте
    printf("%d\n", x);  // 10
}

// Другое место
int x = 10;  // Определение переменной x
\end{lstlisting}
    \item \verb*|static| -- если ключевое слово указано перед локальной переменной, то \emph{значение будет сохраняться между вызовами функции}. \emph{Инициализация} статических локальных переменных производится только при первом вызове функции. При последующих вызовах используется сохраненное ранее значение.
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
#include <stdio.h>

int func(void);  // объявление функции

int main(void) {
    printf("%d\n", func()); // 1
    printf("%d\n", func()); // 2
    printf("%d\n", func()); // 3
    
    return 0;
}

int func(void) {
	// статические локальные переменные инициализируются только один раз
	// при первом вызове функции
    static int x = 0;  
    ++x;
    return x;
}
\end{lstlisting}

Пори каждом вызове функции \verb*|func()| значение статической переменной \verb|x| будет увеличиватся на единицу. Если убрать ключевое слово \verb*|static|, то при каждом вызове будет выводиться число 1, так как \emph{автоматические локальные переменные} инициализируются при входе в функцию и уничтожаются при выходе из нее.

Если ключевое слово \verb|static| указано перед \emph{глобальной} переменной, то ее значение будет \emph{видимо только в пределах файла}.
\end{itemize}

В Python поведение статической локальной переменной можно симитировать, например, с помощью ключевого слова \verb*|global|
\begin{lstlisting}[
style = ironpython,
numbers = none
]
x = 0

def func() -> int:
    global x
    x += 1
    return x

def main():
	print(func())  # 1
	print(func())  # 2
	print(func())  # 3
	
if __name__ == "__main__":
    main()
\end{lstlisting}

Очень важно учитывать, что переменная, объявленная \emph{внтури блока}, \emph{видна} \emph{только в пределах блока} (внутри фигурных скобок) \cite[\strbook{106}]{prokhorenok-prog-c:2020}.

\subsection{Массивы}

Массив -- это нумерованный набор переменных одного типа. Объем памяти массива (в байтах), занимаемый массивом, определяется так
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
<Объем памяти> = sizeof(<Тип>) * <Количество элементов>
\end{lstlisting}

Объявление массива выглядит следующим образом
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
<Тип> <Переменная>[<Количество элементов>];
// Пример
long arr[3] = {10, 20, 30};
\end{lstlisting}

После закрывающей фигурной скобки обязательно указывается точка с запятой. Количество значений внутри фигруных скобок может быть меньше количества элементов массива.

В рассмотренном примере первому элементу массива присваивается значение 10, второму -- значение 20, а третьему элементу будет присвоено значение 0.

Если при объявлении массива указыается начальные значения, то количество элементов внутри квадратных скобок можно не указывать
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
long arr[] = {10, 20, 30};

for (int i = 0; i < 3; ++i) {
    printf("arr[i=%d] = %ld", i, arr[i]);
}
\end{lstlisting}

Если при объявлении массива начальные значения не указаны, то:
\begin{itemize}
	\item элементам глобальных массивов автоматически присваивается значение 0;
	
	\item элементы локальных массивов будут содержать произвольные значения, так называемый <<мусор>>.
\end{itemize}

NB: следует учитывать, что \emph{проверка выхода} указанного \emph{индекса} за пределы диапазона на этапе компиляции \emph{\color{red}не производится}. Таким образом, можно перезаписать значение в смежной \emph{ячейке памяти} и тем самым нарушить работоспособность программы или \emph{даже повредить операционную систему} \cite[\strbook{108}]{prokhorenok-prog-c:2020}.

Все элементы массива располагаются в \emph{смежных ячейках памяти}. После определения массива выделяется необходимый размер пмяти, а в \emph{переменной} сохраняется \emph{адрес первого элемента} массива.

\subsubsection{Строка}

Строка является массивом символов, последний элемент которого содержит нулевой символ (\verb*|'\0'|). Такие строки часто называют \emph{C-строками}.

Присваивать строку в двойных кавычках можно только при инициализации. Объявить массив строк можно следующим образом
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
char valid_solver_names[][10] = {"gurobi", "cplex", "scip"};

// обойти массив строк
for (int i = 0; i < 3; ++i) {
    printf("%s", valid_solver_names[i]);
}
\end{lstlisting}

\subsubsection{Указатели}

\emph{Указатель} -- это \emph{переменная}, которая предназначена для \emph{хранения адреса}. В языке Си указатели часто используются в следующих случаях:
\begin{itemize}
	\item для управления динамической памятью,
	
	\item чтобы иметь возможность изменить значение переменной внутри функции,
	
	\item для эффективной работы с массивами и др.
\end{itemize}

Объявлнеие укзателя имеет следующий формат:
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
<Тип> *<Переменная>;
// Пример
int *p = NULL;
\end{lstlisting}

Для того чтобы \emph{указателю} \underline{\itshape присвоить} \emph{адрес переменной}, необходимо при присваивании значения перед названием переменной добавить оператор \verb*|&|. Типы данных переменной и указателя должны совпадать. Это нужно, чтобы при адресной арифметике был известен размер данных
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
int *p = NULL, x = 10;
p = &x;  // присваивание указателю адреса переменной
printf("%d\n", *p); // чтение значения по адресу; 10

*p = *p + 20;   // изменение значения
printf("%d\n", p*);  // ; 30
\end{lstlisting}

Указатель, которому присвоено значение \verb|NULL| (это макрос), называется \emph{нулевым указателем}.

\emph{Глобальные} и \emph{статические локальные указатели} автоматические получают значение 0. Однако \emph{указатели}, которые объявлены в \emph{локальной области видимости}, будут иметь \emph{\color{red}произвольные значения}. Если попытаться записать какое-либо значение через такой указатель, то можно повредить операционную систему. Поэтому, согласно соглашению, указатели, которые ни на что не указывают, должны иметь значение \verb*|NULL| \cite[\strbook{113}]{prokhorenok-prog-c:2020}.

При инициализации указателя ему можно присвоить не только числовое значение, но и строку. Пример
\begin{lstlisting}[
style = c_cpp,
numbers = none	
]
const char *str = "String";
printf("%s\n", str);
\end{lstlisting}

Указатели можно сохранять в массиве. При объявлении \emph{массива указателей} используется следующий синтаксис
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
<Тип> *<Переменная>[<Количество элементов>];
\end{lstlisting}

Пример использования массива указателей
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
int *p[3];  // Массив указателей из 3 элементов
int x = 10, y = 20, z = 30;

p[0] = &x;  // указателю присваивается адрес переменной x
p[1] = &y;
p[2] = &z;

for (int i = 0; i < 3; i++) {
    printf("p[%d] = %d\n", i, *p[i]);
}
\end{lstlisting}

Объявление массива указателей на строки выглядит так
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
const char *str[] = {"String1", "String2", "String3"};
printf("%s\n|, str[0]);  // String1
\end{lstlisting}

\emph{Указатели} очень часто используются \emph{для обращения к элементам массива}, так как \emph{адерсная арифметика} выполняется \emph{эффективнее}, чем доступ по индексу \cite[\strbook{114}]{prokhorenok-prog-c:2020}
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
#include <stdio.h>
#define ARR_SIZE 3  // препроцессорная константна

int main(void) {
    int *p = NULL, arr[ARR_SIZE] = {10, 20, 30};
    p = arr;  // присвоить указателю адрес первого элемента массива arr
    
    for (int i = 0; i < ARR_SIZE; ++i) {
        printf("arr[%d] = %d\n", i, *p);
        ++p;  // переместить указатель на следующий элемент
    }
    p = arr;  // восстановить положение указателя
}
\end{lstlisting}

В строке \verb|p = arr;| \emph{указателю} присваивается \emph{адрес} первого элемента массива. Перед названием массива отсутствует оператор \verb|&|, так как \emph{название переменной} содержит \emph{адрес первого элемента} массива
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
p = &arr[0];  // то же что p = arr;
\end{lstlisting}

В строке \verb*|++p;| увеличивается \emph{значение указателя} на единицу. Здесь изменяется \emph{адрес}, а не значение элемента массива. При увеличении значения указателя используются правила \emph{адресной арифметики}, а не правила обычной.

Увеличение значения указателя на единицу означает, что значение будет \emph{увеличено на \underline{размер типа}}. Например, если тип \verb*|int| занимает 4 байта, то при увеличении значения на единицу указатель вместо адреса \verb|0x0012FF30| будет содержать адрес \verb*|0x0012FF34|. Значение увеличилось на 4, а не 1.

Вместо двух инструкций внутри цикла можно использовать одну
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
printf("%d\n", *p++);  // то же что *(p++)
\end{lstlisting}

Выражение \verb|p++| возвращает \emph{текущей адрес}, а затем увеличивает его на единицу. Символ \verb*|*| позволяет получить \emph{доступ к значению элемента по указанному адресу}.

Получить доступ к элементу массива можно несколькими спосбами
\begin{lstlisting}[
style = c_cpp,
numbers = none	
]
int arr[3] = {10, 20, 30};

printf("%d\n", arr[1]); // 20
printf("%d\n", *(arr + 1));  // 20
printf("%d\n", *(1 + arr));  // 20
printf("%d\n", 1[arr]);  // 20
\end{lstlisting}

С указателем можно выполнять следующие арифметические и логические опреации:
\begin{itemize}
	\item прибавлять целое число; число умножается на размер базового типа указателя, а затем прибавляется к адресу,
	
	\item вычитать целое число,
	
	\item вычитать один указатель из другого. Это позволяет получить количество элементов базового типа между двумя указателями,
	
	\item сравнивать указатели между собой.
\end{itemize}

При использовании ключевого слова \verb*|const| применительно к указателям важно учитывать местоположение ключевого слова \verb|const| \cite[\strbook{116}]{prokhorenok-prog-c:2020}. 

Например
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
// константный указатель
// const действует на значение
const char *str = "String";
char const *str = "String";
\end{lstlisting}
это одно и то же и означает, что значение, на которое ссылается указатель изменять нельзя, но указателю можно присвоить другой адрес.

В этом случае
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
char * const p = "String";  // const действует на адрес
\end{lstlisting}
значение, на которое ссылается указатель изменить можно, но указателю нельзя присвоить другой адрес.

А в этом случае
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
const char * const p = "String";
\end{lstlisting}
запрещается изменение значения, на которое ссылается указатель и присвоение другого адреса.

Указатели часто используются при передаче параметров в функцию. По умолчанию в функцию передается \emph{копия значения переменной}. Если мы в этом случае изменим значение внутри функции, то это действие не затронет значения внешней переменной.

Для того чтобы иметь возможность \emph{изменять} значение внешней переменной, параметр функции объявляют \emph{как указатель}, а при вызове передают адрес переменной.

Передать параметры в функцию можно \emph{по значению} (применяется по умолчанию). При этом создается \emph{копия} значения, и все операции выполняются с копией. Так как локальные переменные видны только внутри тела функции, после завершения выполнения функции копия удаляется. 

А можно передать \emph{по ссылке}. Внутри функции адрес переменной присваивается указателю. Использую операцию \emph{разыменования указателя}, можно \emph{изменить} значение \emph{самой переменной}, а не значение копии. 

\subsubsection{Динамичекое выделение памяти}

При объявлении переменной необходимо указать тип данных, а для массива дополнительно задать точное количество элементов. На основе этой информации при запуске программы автоматически выделяется необходимый объем памяти. После завершения программы память автоматически освобождается. Иными словами, объем памяти необходимо знать до выполнения программы. Во время выполнения программы создать новую переменную или увеличить размер существующего массива нельзя.

Для того чтобы произвести  увеличение массива во время выполнения программы, необходимо выделить достаточный объем \emph{динамической памяти}, перенести существующие элементы, а лишь затем добавить новые элементы. После завершения работы с памятью необходимо самим возвратить память операционной системе. Если этого не сделать, то участок памяти станет недоступным для дальнейшего испольования. Подобные ситуации приводят к утечке памяти.

Для выделения динамической памяти в языке Си предназначена функция \verb*|malloc()|. Функция \verb|malloc()| принимает в качестве параметра размер памяти в байтах и возвращает \emph{указатель}, имеющий тип \verb|void *|. В языке Си указатель типа \verb|void *| неявно приводится к другому типу, поэтому использовать явное приведение не нужно (в языке C++ нужно обязательно выполнять явное приведение).

\begin{lstlisting}[
style = c_cpp,
numbers = none
]
const unsigned ARR_SIZE = 3;
int *p = malloc(ARR_SIZE * sizeof(int));
\end{lstlisting}

Если память выделить не удалось, то функция возвращает \emph{нулевой указатель}. Все элементы будут иметь произвольное значение, <<мусор>>.

Освободить ранее выделенную динамическую память позволяет функция \verb*|free()|. Функция \verb|free()| принимает в качестве параметра указатель на ранее выделенную память и освобождает ее.

Пример использования функций \verb*|malloc()| и \verb*|free()|
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
#include <stdio.h>
#include <stdlib.h>
#inlucde <locale.h>

int main(void) {
    const unsigned ARR_SIZE = 10;
    int *p = malloc(ARR_SIZE * sizeof(int));
    
    if (!p) {
        puts("Oops ...");
        exit(1);
    }
    
    for (int i = 0; i < ARR_SIZE; ++i) {
        p[i] = i + 1;
    }
    
    for (int i = 0; i < ARR_SIZE; ++i) {
        printf("p[%d] = %d", i, p[]);
    }
    
    free(p);  // NB
    p = NULL;  // NB
}
\end{lstlisting}

Вместо функции \verb*|malloc()| можно воспользоваться функцией \verb|alloc()|. Если память выделить не удалось, то функция возвращает нулевой указатель. Все элементы будут иметь значение 0.

Пример динамического выделения памяти под двумерный массив
\begin{lstlisting}[
style = c_cpp,
numbers = none	
]
#include <stdio.h>
#include <stdlib.h>

int main(void) {
    const unsigned int ROWS = 2;
    const unsigned int COLUMNS = 4;
    int i = 0, j = 0;
    
    int **p = calloc(ROWS, sizeof(int*));
    if (!p) exist(1);
    
    for (i = 0; i < ROWS; ++i) {
        p[i] = calloc(COLUMNS, sizeof(int));
        if (!p[i]) exit(1);
    }
    
    int n = 1;
    for (i = 0; i < ROWS; ++i) {
        for (j = 0; j < COLUMNS; ++j) {
            p[i][j] = n++;
            // *(*(p + i) + j) = n++;
        }
    }
    
    for (i = 0; i < ROWS; ++i) {
        for (j = 0; j < COLUMNS; ++j) {
            printf("%3d", p[i][j]);
            // printf("%3d", *(*(p + i) + j));
        }
        printf("\n");
    }
    
    for (int i = 0; i < ROWS; ++i) {
        free(p[i]);
        freep(p);
        p = NULL;
    }
}
\end{lstlisting}

При возвращении памяти вначале освобождается память, выделенная ранее под строки, а лишь затем освобождается память, выделенная ранее под массив указателей.

Строки в памяти могут быть расположены в разных местах, что не позволяет эффективно получать доступ к элементам двумерного массива. Для того чтобы доступ к элементам сделать максимально быстрым, можно представить двумерный массив в виде одномерного массива.
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
#include <stdio.h>
#include <stdlib.h>

int main(void) {
    const unsigned ROWS = 2;
    const unsigned COLUMNS = 4;
    unisgned i = 0, j = 0;
    int *p = calloc(ROWS * COLUMNS, sizeof(int));
    if (!p) exit(1);
    
    int n = 1;
    for (i = 0; i < ROWS; ++i) {
        for (j = 0; j < COLUMNS; ++j) {
            *(p + i * COLUMNS + j) = n++;
        }
    }
    
    for (i = 0; i < ROWS; ++i) {
        for (j = 0; j < COLUMNS; ++j) {
            printf("%3d", *(p + i * COLUMNS + j));
        }
        printf("\n");
    }
    free(p);  // осводбодить память
    p = NULL;  // обнулить указатель
}
\end{lstlisting}

В данном случае все элементы расположены в смежных ячейках, и можно получить доступ к элементам с помощью указателя и адресной арифметики. 

Функция \verb|realloc()| выполняет перераспределение памяти. Функция выделит динамическую память длиной \verb*|newSize|, скопирует в нее элементы из старой области памяти, освободит старую память и вернет указатель на новую область памяти. Новые элементы будут иметь произвольные значения, так называемый <<мусор>>. Если новая длина меньше старой, то лишние элементы будут удалены. Если память не может быть выделена, то функцию вернет \emph{нулевой указатель}, при этом старая область памяти не изменяется (в этом случае возможны утечки памяти, если значение присваивается прежнему указателю).

Пример
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
#include <stdio.h>
#include <stdlib.h>

int main(void) {
    unsigned arr_size = 5;
    int *p = malloc(arr_size * sizeof(int));
    if (!p) exit(1);
    
    for (int i = 0; i < arr_size; i++) {
        *(p + i) = i + 1;  // p[i] = i + 1;
    }
    
    arr_size += 2;
    p = realloc(p, arr_size * sizeof(int));
    // Здесь возможна утечка памяти, если realloc() вернет NULL
    if (!p) exit(1);
    
    *(p + 3) = 55;  // p[3] = 55;
    *(p + 4) = 66;  // p[4] = 66;
    
    for (int i = 0; i < arr_size; i++) {
        printf("%d", *(p + i));
    }
    
    free(p);
    p = NULL;
}
\end{lstlisting}

\subsubsection{Структуры}

\emph{Структура} -- это совокупность переменных (называемых элементами, или полями), объединенных под одним именем. Объявление структуры выглядит следующим образом:
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
struct [<Название структуры>] {
    <Тип данных> <Название поля 1>;
    <Тип данных> <Название поля 2>;
    ...
} [<Объявление переменных через запятую>];
\end{lstlisting}

Допустимо не задавать название структуры, если после закрывающей фигурной скобки указано объяление переменной. \emph{Точка с запятой} в конце объявления структуры является \emph{обязательной}.

Объявление структуры только описывает \emph{новый тип данных}, а не определяет переменную, поэтому память под нее не выделяется. Для того чтобы объявить переменную, ее название указывается после закрывающей фигурной скобки при объвялении структруры или отдельно с помощью названия структуры в качестве типа данных:
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
struct <Название структуры> <Названия переменных через запятую>;
\end{lstlisting}

Одновременно с объявлением переменной можно выполнить инициализацию полей структуры, указав значения внутри фигурных скобок:
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
struct Point point1 = {10, 20};
\end{lstlisting}

Можно указать имя поля
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
struct Point point2 = {.x = 100, .y = 200};
\end{lstlisting}

После объявления переменной выделяется необходимый размер памяти. Для получения размера структуры внутри программы следует использовать оператор \verb*|sizeof|:
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
<Размер> = sizeof(<Переменная>);
<Размер> = sizeof(<struct <>>);
\end{lstlisting}

Одну структру можно присвоить другой с помощью оператора \verb|=|. В этом случае копируются значения всех полей структуры.

Структуры можно вкладывать. При обращении к полю вложенной структуры дополнительно указывается название структуры родителя
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
#incude <stdio.h>

struct Point {
    int x;
    int y;
};

struct Rectangle {
    struct Point top_left;
    struct Point bottom_right;
};

int main(void) {
    struct Rectangle rec = {
        .top_left = {
            .x = 100,
            .y = 200,
        },
        .bottom_right = {
            .x = -1,
            .y = -2,
        }
    };
    
    printf("top left x: %d", rec.top_left.x);
    printf("bottom right y: %d", red.bottom_right.y);
}
\end{lstlisting}

Адрес структуры можно сохранить в указателе. Для получения адреса структуры используется оператора \verb*|&|, а для доступа к полю структуры вместо точки применяется оператор \verb|->|
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
#include <stdio.h>

struct Point {
    int x;
    int y;
} point1;

int main(void) {
    struct Point *p = &point1;
    
    p->x = 10;
    p->y = 20;
    
    printf("%d\n", p->x);
    printf("%d\n", (*p).y);
}
\end{lstlisting}

\subsubsection{Битовые поля}

\emph{Битовые поля} предоставляют доступ к отдельным битам, позволяя тем самым хранить в одной переменной несколько значений, занимающих указанное количество битов. Один бит может содержать только числа 0 или 1.

Битовые поля объявляются только с типом \verb*|int|. В одной структуре можно использовать одновременно битовые поля и обычные поля. Название битового поля можно не указывать. Кроме того, если длина поля составляет 1 бит, то дополнительно следует указать ключевое слово \verb|unsigned|
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
struct Status {
    unsigned int flag1:1;
    unsigned int flag2:1;
    unsigned int flag3:1;
} status = {0, 1, 1};

printf("%d\n", status.flag1);  // 0
status.flag2 = 1;
printf("%d\n", (int)sizeof(struct Status));
\end{lstlisting}

\subsubsection{Объединения}

\emph{Объединение} -- это область памяти, используемая для хранения данных \emph{разных} типов. В один момент времени в этой области могут храниться данные только одного типа. Размер будет соответствовать размеру более сложного типа данных. Например, если внутри объединения определены переменные, имеющие типы \verb*|int|, \verb|float| и \verb*|double|, то размер объединения будет соответствовать размеру типа \verb|double|. Точка с запятой в конце объявления обязательна. Объединение только описывает новый тип данных, а не определяет переменную, поэтому память под нее не выделяется.

\subsubsection{Перечисления}

\emph{Перечисление} -- это совокупность целочисленных констант, описывающих все допустимые значения переменной. Точка с запятой в конце объявления явлюятся обязательной.

Пример
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
enum Color {
    RED,  // 0
    BLUE,  // 1
    GREEN,  // 2
    BLACK  // 3
};
\end{lstlisting}

Константам \verb*|RED|, \verb|BLUE| ... автоматически присваиваются целочисленные значения, начиная с нуля.

При объявлении перечисления константе можно присвоить другое значение. В этом случае последующая константа будет иметь значение на единицу больше того, другого значения. Пример
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
enum Color {
    RED = 3,
    BLUE,  // 4
    GREEN = 7,
    BLACK  // 8
} color1;
\end{lstlisting}

Операторы инкремента и декремента могут использоваться в постфиксной или префиксной форме. При постфиксной форме (\verb*|x++|) сначала возвращается значение, а потом выполняется операция. В префиксной форме (\verb|++x|) сначала выполняется операция, а потом возвращается значение.

При вложении операторов \verb|if| можно воспользоваться следующей схемой
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
if (<Cond-1>) {
    // Block-1
}
else if (<Cond-2>) {  // получается как elif в Python
    // Block-2
}
else {
    // Block-3
}
\end{lstlisting}

Тернарный оператор
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
int x = 10;
printf("%d %s\n", x, (x % 2 ==0) ? "- четное число" : "- нечетное число");
\end{lstlisting}

В качестве операндов указываются именно выражения, а не инструкции. Кроме того, выражения обязательно должны возвращать какое-либо значение, причем одинакового типа.

В качестве операнда можно указать функцию, которая возвращает значение
\begin{lstlisting}[
style = c_cpp,
numbers = none	
]
int func1(int x) {
    printf("%d %s\n", x, "...");
}

int func2(int x) {
    printf("%d %s", x, "...");
}

int x = 10;
// значение, возвращаемое оператором можно проигнорировать
(x % 2 == 0) ? func1(x) : func2(x);
\end{lstlisting}

В языке Си практически все элементарные типы данных (\verb|_Bool|, \verb*|char|, \verb|int|, \verb|float|, \verb|double|) являются числовыми. Тип \verb|_Bool| может содержать только значения 1 и 0, которые соответствуют значениям Истина и Ложь. Тип \verb|char| содержит \emph{код символа}, а не сам символ. Поэтому значения этих типов можно использовать в одном выражении вместо со значениями, имеющими типы \verb|int|, \verb|float| и \verb|double|. Пример
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
_Bool a = 1;
char ch = 'w';

printf("%d\n", a + ch + 10);  // 130
\end{lstlisting}

Знак числа хранится в \emph{старшем бите}: 0 соответствует положительному числу, 1 -- отрицательному.

При преобразовании значения из типа \verb|signed| в тип \verb|unsigned| следует учитывать, что знаковый бит (если число отрицательное, то бит содержит значение 1) может стать причиной очень больших чисел, так как старший бит у типа \verb|unsigned| не содрежит признака знака
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
int x = -1;
printf("%u\n", (unsigned int)x);  // 4294967295
\end{lstlisting}

Присвоить всем элементам массива значение 0 можно так
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
long arr[3] = {0};
for (int i = 0; i < 3; i++) {
    printf("arr[%d] = %d\n", i, arr[i]);  // 0 0 0
}
\end{lstlisting}

Количество элементов массива задается при объявлении и не может быть изменено позже. Поэтому лучше количество элементов сохранить в каком-нибудь макросе и в дальнейшем указывать этот макрос, например, при переборе элементов массива.

\remark[red]{
Следует учитывать, что проверка выхода указанного индекса массива за пределы диапазона на этапе компиляции не произодится. Таким образом, можно перезаписать значение в смежной ячейке памяти и тем самым нарушить работоспособность программы или даже повредить операционную систему. Контроль корректности индекса входит в обязанности программиста!
}

После определения массива выделяется необходимый размер памяти, а в переменной сохраняется \emph{адрес первого элемента массива}. Цикл \verb|for| всегда можно заменить циклом \verb|while|.

Вместо доступа к элементу массива по индексу, указанному в квадратных скобках (\texttt{p[i]}\footnote{В этом случае положение элемента \emph{каждый раз} вычисляется относительно начала массива, то есть \texttt{*(p + i)}}, где \verb|p| -- указатель) лучше использовать адресную арифметику, просто перемещая указатель. Тогда никаких дополнительных вычислений положения элемента внутри массива производится не будет.

Сортировка пузырьком
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
#include <stdio.h>

#define ARR_SIZE 5

int main(void) {
    int arr[ARR_SIZE] = {10, 5, 6, 1, 3};
    int tmp = 0, k = ARR_SIZE - 2;
    _Bool is_swap = 0;
    
    for (int i = 0; i <= k; ++i) {
        for (int j = k; j >= i; j--) {
            if (arr[j] > arr[j + 1]) {
                tmp = arr[j + 1];
                arr[j + 1] = arr[j];
                arr[j] = tmp;
                is_swap = 1;
            }
        }
        if (!is_swap) break;
    }
    for (int i = 0; i < ARR_SIZE; ++i) {
        printf("%d\n", arr[i]);
    }
}
\end{lstlisting}

Этот же алгоритм на Python выглядел бы так
\begin{lstlisting}[
style = ironpython,
numbers = none
]
def bubble_sort(arr: t.List[int]) -> t.List[int]:
    """Bubble sorting algorithm"""
    for i in range(k + 1):  # i in [0, k]
        is_swap = False
        for j in range(k, i - 1, -1):  # j in [k, i]
            if (arr[j] > arr[j + 1]):
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
                is_swap = True
        
        if not is_swap:
            break
            
    return arr
\end{lstlisting}

\section{Символы и C-строки}

В языке Си доступны два типа строк: \emph{C-строка} и \emph{L-строка}. C-строка является \emph{массивом \underline{однобайтовых} симолов} (тип \verb*|char|), последний элемент которого содержит \emph{нулевой символ} (\verb|'\0'|). Обратите внимание, что нулевой символ (нулевой байт) не имеет никакого отношения к символу \verb*|'0'|. Коды этих символов разные. L-строка является \emph{массивом \underline{широких} символов} (тип \verb*|wchar_t|), последний элемент которого содержит \emph{нулевой символ}.

Для хранения символа используется тип \verb*|char|. Переменной, имеющей тип \verb|char|, можно присвоить числовое значение (код символа) или указать символ внутри апострофов. Внутри апострофов можно указать \emph{специальные символы} -- комбинации знаков, соответсвтующих служебным или непечатаемым символам (\verb*|\0|, \verb|\n|, \verb|\r|, ...).

Когда переменной присваивается символ внутри апострофов, он автоматически преобразуется в соответствующий целочисленный код.

Присвоить строку в двойных кавычках можно только при инициализации
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
char str[7] = "String";  // емкость 7, потому что 6 однобайтовых символов + нулевой символ '\0'
\end{lstlisting}

Но строку можно скопировать
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
char str[7];
strcpy(str, 7, "String");
\end{lstlisting}

Разместить С-строку при инициализации на нескольких строках нельзя. Чтобы разместить С-строку при нескольих строках, следует перед символом перевода строки указать символ \verb|\|
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
char str[] = "string1 \
string2 \
string3";
\end{lstlisting}

Можно воспользоваться неявной конкатенацией. Если строки расположены подряд внутри одной инструкции, то они объединяются в одну большую строку
\begin{lstlisting}[
style = c_cpp,
numbers = none	
]
char str[] = "string1"
"string2" "string3";
\end{lstlisting}

\emph{Строку можно присвоить указателю}, но в этом случае строка будет доступна \emph{только для чтения} \cite[\strbook{224}]{prokhorenok-prog-c:2020}
\begin{lstlisting}[
style = c_cpp,
numbers = none	
]
const char *p = "string";
printf("%s\n", p); // string
\end{lstlisting}

Мы можем объявить несколько указателей и присвоить им одинаковую строку, но все они будут ссылаться на один и тот же адрес. Иными словами, строка, указанная в программе внутри двойных кавычек, в памяти существует в единственном экземпляре. Если бы была возможность изменить такую строку, то она изменилась бы во всех указателях. Поэтому строка, присвоенная указателю, доступна только для чтения.

Объявление \emph{массива строка} выглядит так
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
char str[][20] = {"String1", "String2", "String3"};
\end{lstlisting}

Или так
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
char *str[] = {"String1", "String2", "String3"};
\end{lstlisting}

При использовании второго способа попытка изменения символа приведет к ошибке при выполнении программы. Так что эти способы не эквивалентны.

После определения С-строки в переменной сохраняется адрес первого символа. Иными словами, название переменной является \emph{указателем}, который \emph{ссылается} на первый символ строки. Поэтому доступ к символу в строке может осуществляться как по индексу, так и с использованием адресной арифметики.

Символ можно не только получить таким образом, но и изменить (например, в Python таким спобом изменить строку нельзя)
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
char str[] = "string";

str[0] = 'C';  // с помощью индекса
*(str + 1) = 'T';  // с помощью указателя
\end{lstlisting}

Объявить указатель и присвоить ему адрес строки можно следущим образом:
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
char str[] = "string";
char *p = NULL;

p = str;
*p = 'S';
++p;
*p = 'T';
\end{lstlisting}

Получить длину строки можно с помощью функции \verb|strlen()| -- возвращает количество символов без учета нулевого символа.
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
char solver_name[] = "gurobi";
printf("%d\n", strlen(solver_name));
\end{lstlisting}

При использовании L-строк все символы кодируются 2 байтами. Не следует рассматривать L-строку, как строку в какой-то кодировке, например в UTF-16. Нужно думать об L-строке как о строке в \emph{абстрактной кодировке}, позволяющей закодировать более 65 000 символов. Когда мы говорим о строке в какой-либо кодироке, мы всегда подразумеваем C-строку.

\section{Пользовательские функции}

\emph{Функция} -- это фрагмент кода, который можно неоднократно вызывать из любого места программы. Описание функции состоит из двух частей: \emph{объявления} и \emph{определения}. Объявляение функции (называемое также \emph{прототипом функции}) содержит информацию о типе. Используя эту инфомрацию, компилятор может найти несоответствие типа и количества параметров.

\verb|<Тип результата>| задает \emph{тип значения}, которое возвращает функция с помощью оператора \verb|return|. Если функция не возвращает никакого значения, то \emph{вместо типа} указывается \emph{ключевое слово} \verb|void|. Если функция не принимает параметров, то указываются круглые скобки, внутри которых задается ключевое слово \verb|void|. После объявления функции должна стоять точка с запятой.

\emph{Определение функции} содержит описание типа и названия параметров, а также реализацию. В отличие от прототипа в определении функции после типа обязательно должно быть указано \emph{название параметра}, которое является \emph{локальной переменной}. Эта переменная \emph{создается при вызовае функции}, а \emph{после выхода из функции она удаляется}. Таким образом, локальная переменная видна только внутри функции.

Вернуть значение из функции позволяет оператор \verb|return|. После исполнения этого оператора выполнение функции останавливается, и управление передается обратно в точку вызова функции. Это означает, что инструкции после оператора \verb|return| никогда не будут выполнены.

Если перед названием функции указано ключевое слово \verb|void|, то оператора \verb|return| может не быть. Однако если необходимо досрочно прервать выполнение функции, то оператор \verb|return| указывается без возвращаемого значения.

Все инструкции в программе выполняются последовательно сверху вниз. Это означает, что прежде чем использовать функцию в программе, ее необходимо предварительно \emph{объявить}. Поэтому \emph{объявление функции} должно быть расположено \emph{перед вызовом функции}. Название функции всегдя является \emph{глобальным идентификатором}.

\emph{Объявления функций} следует размещать в начале программы \underline{\itshape перед} функцией \verb|main()|, а \emph{определения} -- \underline{\itshape после} функции \verb|main()|. В этом случае порядок следования определений функций не имеет значения \cite[\strbook{315}]{prokhorenok-prog-c:2020}. Пример
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
#include <stdio.h>

int sum_i(int, int);  // объявление

int main(void) {
    int z = sum_i(10, 20);
    printf("z = %d\n", z);  // z = 30
    return 0;
}

int sum_i(int x, int y) {  // определение
    return x + y;
}
\end{lstlisting}

При увеличении размера программы объявлений и определений функций становится все больше и больше. В этом случае программу разделяют на несколько отдельных файлов. Объявления функций выносят в заголовочный файл с расширением \verb|h|, а определения функций размещают в \emph{одноименном} файле с расширением \verb|c|. 

Все файлы располагают в одном каталоге с основным файлом, содержащим функцию \verb|main()|. В дальнейшем с помощью директивы \verb|#include| подключают заголовочный файл во всех остальных файлах. Если в директиве \verb|#include| название заголовочного файла указывается в угловых скобках, то поиск файла осуществляется в \emph{путях поиска заголовочных файлов}. Если название указано внутри кавычек, то поиск \emph{вначале} производится \emph{в каталоге с основным файлом}, а \emph{затем} в путях поиска заголовочных файлов.

Пример
\begin{lstlisting}[
title = {\sffamily my\_module.c},
style = c_cpp,
numbers = none
]
#include "my_module.h"  // подключение заголовочного файла

int sum_i(int x, int y) {  // определение
    return x + y;
}
\end{lstlisting}

\begin{lstlisting}[
title = {\sffamily my\_module.h},
style = c_cpp,
numbers = none
]
#ifndef MY_MODULE_H_
#define MY_MODULE_H_

#include <stdio.h>
int sum_i(int, int);  // объявление

#endif /* MY_MODULE_H_ *
\end{lstlisting}

Все содержимое файла \verb|my_module.h| расположено внутри условия, которое проверяется перед компиляцией. Условие выглядит так
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
#ifndef MY_MODULE_H_
// Инструкции
#endif  /* MY_MODULE_H_ */
\end{lstlisting}

Это условие следует читать так: если не существует макроопределение \verb|MY_MODULE_H_|, то вставить инструкции в то место, где подключается файл. Название макроопределения обычно совпадает с названием заголовочного файла. Только все буквы указываются в верхнем регистре и точка заменяется символом подчеркивания. Все это необходимо, чтобы объявления идентификаторов не вставлялись дважды.

Вместо этих директив можно указать в самом начале \emph{заголовчного файла} директиву препроцессора \verb|#pragma| со значением \verb|once|, которая также препятствует повторному включению файла
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
#pragma once
// Объявление функций и др.
\end{lstlisting}

\begin{lstlisting}[
title = {\sffamily Основаная программа},
style = c_cpp,
numbers = none
]
#include "my_module.h"

int main(void) {
    int z = sum_i(10, 20);
    printf("z = %d\n", z);
    return 0;
}
\end{lstlisting}

При использовании больших программ создают \emph{статическую} или \emph{динамическую} библиотеку. Статические библиотеки становятся частью программы при компиляции, а динамические библиотеки подгружаются при запуске программы.

\subsection{Способы передачи параметров в функцию}

В определении функции после типа обязательно должно быть указано \emph{название параметра}, которое является \emph{локальной переменной}. Эта переменная создается при вызове функции, а после выхода из функции она удаляется. Таким образом, локальная переменная видна только внутри функции, и ее значение между вызовами не сохраняется (исключением являются \emph{статические переменные}). 

По умолчанию в функцию передается \emph{копия} значения переменной. Таким образом, изменение значения внутри функции не затронет значение исходной переменной.

Передача копии значения для чисел является хорошим решением, но при использовании массивов, а также при необходимости изменить значение исходной переменной, лучше применить \emph{передечу указателя}. Для этого при вызове функции перед названием переменной указывается оператор \verb|&| (взятие адреса), а в прототипе функции объявляется указатель. В этом случае в функцию передается \emph{не значение переменной}, а \emph{ее адрес}. Внутри функции вместо переменной используется \emph{указатель}
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
#include <stdio.h>

void func(int *px);

int main(void) {
    int x = 10;
    func(&x);
    printf("%d\n", x);  // 30, а не 10
    return 0;
}

void fund(int *px) {
    *px += 20;
}
\end{lstlisting}

\subsection{Передача массивов и строк в функцию}

Многомерный массив в функцию лучше передавать как одномерный \cite[\strbook{322}]{prokhorenok-prog-c:2020}. В этом случае в функцию передается адрес  первого элемента массива, а в параметре объявляется указатель. Так как все элементы массива располагаются в памяти последовательно, зная количество элементов или размеры, можно вычислить положение текущего элемента, используя адресную арифметику.
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
#include <stdio.h>

#define ARR_ROWS 2
#define ARR_COLS 4

void func(int *pa, int rows, int cols);

int main(void) {
    int arr[ARR_ROWS][ARR_COLS] = {
        {1, 2, 3, 4},
        {5, 6, 7, 8}
    };
    
    func(arr[0], ARR_ROWS, ARR_COLS);  // arr[0] !!!
    return 0;
}

void func(int *pa, int rows, int cols) {
    for (int i = 0, j; i < rows; ++i) {
        for (j = 0; j < cols; ++j) {
            printf("%2d ", *(pa + i * cols + j));
            // printf("%2d ", pa[i * cols + j]);
        }
        printf("\n");
    }
}
\end{lstlisting}

Передача в функцию \emph{массива С-строк} осуществляется так же, как передча \emph{массива указателей}. Для того чтобы в функцию не передавать количество элементов, можно при инициализации массива С-строк последнему элементу присвоить нулевой указатель. Этот элемент будет служить ориентиром конца массива.
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
#include <stdio.h>

void func(char *s[]);

int main(void) {
	// массив С-строк как массив указателей на char
    char *str[] = {"String1", "String2", "String3", NULL};
    
    func(str);
    return 0;
}

void func(char *s[]) {  // или void func(char **s) 
	// s -- это указатель, а не массив!
    while (*s) {
        printf("%s\n", *s);
        ++s;
    }
}
\end{lstlisting}

Передача одномерных массивов и строк осуществляется с помощью \emph{указателей}. Объявление \verb|char *s| эквивалентно объявлению \verb|char s[]|. И в том и в другом случае \emph{объявляется указатель на тип} \verb|char|. Чаще используется первый способ.

\subsection{Переменное количество параметров}

Количество параметров в функции может быть произвольным при условии, что существует один обязательный параметр. В объявлении и определении функции \emph{переменное число параметров} обозначается тремя точками. Например
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
int printf(const char *format, ...);
\end{lstlisting}

Вначале объявляется указатель типа \verb|va_list|. Далее должна производится инициализация указателя с помощью макроса \verb|va_start()|. В первом параметре передается указатель, а во втором -- название последнего обязательного параметра. Доступ к параметрам осуществляется с помощью макроса \verb|va_arg()|, который возвращает значение текущего параметра и перемещает указатель на следующий параметр. В первом параметре макроса \verb|va_arg()| передается указатель, а во втором -- название типа данных. Макрос \verb|va_end()| сообщает об окончании перебора параметров. Пример
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
#include <stdio.h>
#include <stdarg.h>

int sum(int n, ...);

int main(void) {
    printf("%d\n", sum(2, 20, 30)); // 50
    printf("%d\n", sum(3, 1, 2, 3));  // 6
    return 0;
}

int sum(int n, ...) {
    int result = 0;
    va_list p;  // указатель типа va_list
    va_start(p, n);  //  инициализация указателя
    for (int i = 0; i < n; ++i) {
        result += va_arg(p, int);
    }
    va_end(p);  // окончание перебора параметров
    return result;
}
\end{lstlisting}

При передаче в функцию значения типа \verb|char| и \verb|short| автоматически расширяются до типа \verb|int|, а значение типа \verb|float| -- до типа \verb|double|.

\subsection{Константные параметры}

Если внутри функции значение параметра не изменяется, то такой параметр следует объявить константным. Для этого при объявлении перед параметром указывается ключевое слово \verb|const|. Пример
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
int sum(const int x, const int y) {
    return x + y;
}
\end{lstlisting}

При использовании указателей важно учитывать местоположение ключевого слова \verb|const|. 
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
void print(const char *s) {  // или char const *s
	// s -- указатель!
    char s2[] = "New";  // C-строка
    s = s2;  // указателю присваивается адрес первого символа строки; там можно
    s[0] = 's';  // Ошибка!
}
\end{lstlisting}

\begin{lstlisting}[
style = c_cpp,
numbers = none
]
void print(char * const s) {
	// s - указатель!
    char s2[] = "New";  // C-строка
    s[0] = 's';  // Можно
    s = s2;  // Ошибка
}
\end{lstlisting}

\begin{lstlisting}[
style = c_cpp,
numbers = none
]
void print(const char * const s) {
    // s - указатель!
    char s2[] = "New";
    s = s2;  // Ошибка
    s[0] = 's';  // Ошибка
}
\end{lstlisting}

\subsection{Статические переменные и функции}

Переменные, указанные в \emph{параметрах}, а также переменные, объявленные внутри функции, являются \emph{локальными переменными}. Эти переменные \emph{создаются при вызове функции}, а \emph{после выхода из функции они удаляются}. 

\emph{Статические} переменные позволяют отказаться от использования глобальных переменных, для \emph{сохранения промежуточных значений} между вызовами функции. Инициализация статической переменной производится только при первом вызове функции. Если пре объявлении статической переменной не присвоено начальное значение, то переменная автоматически инициализируется нулевым значением. После завершения работы функции статическая переменная сохраняет свое значение, кторое доступно при следующем вызове функции.

Ключевое слово \verb|static| можно также указать для глобальной переменной, или функции. В этом случае \emph{область видимости} будет ограничена \emph{текущим файлом}.

Вернуть значение из функции позволяет оператор \verb|return|. После исполнения этого оператора выполнение функции останавливается, и управление передается обратно в точку вызова функции. Это означает, что инструкции после оператора \verb|return| никогда не будут выполнены.

Если внутри функции нет оператора \verb|return|, то по достижении закрывающей фигурной скобки управление будет передано в точку вызова функции. В этом случае возвращаемое значение не определено.

Если функция не возвращает никакого значения, то вместо типа данных в объявлении и определении функции указывается ключевое слово \verb|void|.

Функция может вернуть значение любого типа, кроме массива \cite[\strbook{328}]{prokhorenok-prog-c:2020}. Работать с массивом необходимо через параметры функции, передавая указатель на него или возвращая указатель на конкретный элемент. Вызов функции, возвращающий какое-либо значение, можно разместить внутри выражения с правой стороны от оператора \verb|=|.

Функция может возвращать указатель
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
#include <stdio.h>
#include <string.h>

char *func(char *s);

int main(void) {
    char *p = NULL, str[] = "String";
    
    printf("Size of 'str': %d bytes\n", (int)sizeof(str));  // 7 байт, т.к. str -- это массив
    
    p = func(str);
    if (p) {
        printf("%c\n", *p);
    }
    else {
        puts("NULL");
    }
    return 0;
}

char *func(char *s) {
    if (!s) return NULL;
    size_t len = strlen(s);  // получаем длину строки
    printf("Size of 's': %d bytes\n", (int)sizeof(s));  // 8 байт, т.к. s -- указатель
    if (!len) return NULL;  // нулевой указатель, если пусто
    else return &s[len - 1];  // указатель на последний символ
}
\end{lstlisting}

Нельзя возвращать указатель на переменные или массивы, объявленные внутри функции, так как при выходе из функции локальные переменные будут удалены \cite[\strbook{329}]{prokhorenok-prog-c:2020}.

\subsection{Указатели на функции}

\emph{Функции} так же, как и переменные, имеют \emph{адрес}, который можно \emph{сохранить в указателе}. Объявление указателя на функцию
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
<Тип> (*<Название указателя>) ([<Тип 1>[, ..., <Тип N>]]);
\end{lstlisting}

Для того чтобы \emph{присвоить указателю адрес функции}, необходимо указать назнвание функции без параметров и круглых скобок справа от оператора \verb|=|. Типы параметров указателя и функции должны совпадать
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
int (*pfunc) (int, int) = NULL;
pfunc = sum;  // указателю присваивается адрес функции
\end{lstlisting}

Вызвать функцию через указатель можно так
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
int x = pfunc(30, 10);  // аналогично x = sum(30, 10);
// или так
int y = (*pfunc)(30, 10);
\end{lstlisting}

Пример
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
// Объявления функций
void print_ok(void);
int add(int x, int y);
int sub(int x, int y);
int func(int x, int y, int (*pfunc)(int, int));

int main(void) {
    // Объявления указателей на функции
    void (*pf1)(void) = NULL;
    int (*pf2)(int, int) = NULL;
    
    // Присваивания адреса функции
    pf1 = print_ok;
    pf2 = add;
    
    // Вызов функции через указатели
    pf1();
    printf("%d\n", pf2(10, 20));
    
    printf("%d\n", func(10, 5, pf2));
    printf("%d\n", func(10, 5, add));
    printf("%d\n", func(10, 5, sub));
}

void print_ok(void) {
    puts("OK");
}

int add(int x, int y) {
    return x + y;
}

int sub(int x, int y) {
    return x - y;
}

int func(int x, int y, int (*pfunc)(int, int)) {
    return pfunc(x, y);
}
\end{lstlisting}

\subsection{Передача в функцию и возврат данных произвольного типа}

Если в функцию нужно передать данные \emph{произвольного типа} или вернуть данные произвольного типа, то нужно использовать указатели с типом \verb|void *|. Пример объявления укзателя
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
void *p = NULL;
\end{lstlisting}

Присвоить адрес указателю можно, как обычно
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
int x = 10;
p = &x;
\end{lstlisting}

Для того чтобы получить значение, нужно привести указатель к определенному типу, а затем выполнить разыменование указателя
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
printf("%d\n", *((int *)p));
\end{lstlisting}

\emph{Нетипизированный указатель} можно присвоить \emph{типизированному}. В этом случае в языке Си приведение типа выполняется автоматически
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
int *px = p;  // int *px = (int *)p;
\end{lstlisting}

Можно сохранить в указателе данные любого типа, но, чтобы получить данные, нужно знать, к какому типу выполнить приведение
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
double y = 20.2123;
p = &y;  // нетипизированному указателю присваивается адрес переменной
printf("%.1f\n", *((double *)p));
\end{lstlisting}

\section{Чтение и запись файлов}

Для открытия файла предназначены функции \verb|fopen| и \verb|_wfopen|. В первом параметре функции принимают путь к файлу, а во втором -- режим открытия файла. Функции возвращают \emph{указатель на структуру} \verb|FILE| или нулевой указатель в случае ошибки.
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
#include <stdio.h>

FILE *fp = NULL;  // указатель на структуру FILE

fp = fopen("C:\\book\\file1.txt", "w");
if (fp) {
    fputs("String", fp);
    fclose(fp);
} else puts("Oops. Error");
\end{lstlisting}

Количество одновременно открытых файлов ограничено значением макроса \verb|FOPEN_MAX|. Определение макроса выглядит так
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
#define FOPEN_MAX 20
\end{lstlisting}

В параметре \verb|filename| в функциях \verb|fopen()| и \verb|_wfopen()| указывается путь к файлу. Путь может быть абсолютным или относительным (в этом случае путь определяется с учетом местоположения текущего рабочего каталога). 

Если файл запускается из командной строки, то текущим рабочим каталогом будет каталог, из которого запускается файл. Получить строковое предсталвение текущего рабочего каталога позволяет функция \verb|getcwd()| (заголовочный файл \verb|unistd.h|).

Параметр \verb|mode| в функциях \verb|fopen()| и \verb|_wfopen()| может принимать следующие значения внутри строки:
\begin{itemize}
	\item \verb|r| -- только чтение. Если файл не существует, то функции возвращают нулевой указатель.
	
	\item \verb|r+| -- чтение и запись. Если файл не существует, то функии возвращают нулевой указатель.
	
	\item \verb|w| -- запись. Если файл не существует, то он будет создан. Если файл существует, то он будет перезаписан.
	
	\item \verb|w+| -- чтение и запись. Если файл не существует, то он будет создан. Если файл существует, то он будет перезаписан.
	
	\item \verb|a| -- запись. Если файл не существует, то он будет создан. Запись осуществляется в конец файла. Содержимое файла не удаляется.
	
	\item \verb|a+| -- чтение и запись. Если файл не сущствует, то он будет создан. Чтение производится с начала файла. Запись осуществляется в конец файла. Содержимое файла не удаляется.
\end{itemize}

Функция \verb|fputs()| записывает С-строки в файл. Для ускорения работы производится буферизация записываемых данных. Информация из буфера записывается в файл полностью только в момент закрытия файла. \emph{Сбросить буфер в файл} явным образом можно с помощью функции \verb|fflush()|.

Функция \verb|fwrite()| -- записывает объекты произвольного типа в файл. Файл должен быть открыт в бинарном режиме. Функция возвращает количество записанных объектов.

Функция \verb|fread()| -- считывает из файла объект произвольного типа. Файл должен быть открыт в бинарном режиме.

Пример
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
#include <stdio.h>
#include <stdlib.h>

struct Point {
    int x;
    int y;
} point1, point2;

int main(void) {
    FILE *fp = NULL;
    fp = fopen("./file.txt", "wb");
    if (!fp) {
        perror("Error");
        exit(1);
    }
    
    point1.x = 10;
    point1.y = 20;
    
    size_t n = fwrite(&point1, sizeof(struct Point), 1, fp);
    fflush(fp);  // сбросить буфер в файл
    fclose(fp);
    
    fp = fopen("./file.txt", "rb");
    if (!fp) {
        perror("Error");
        exit(1);
    }
    
    n = fread(&point2, sizeof(struct Point), 1, fp);
    printf("%d\n", point2.x);
    printf("%d\n", point2.y);
    printf("%d\n", (int)sizeof(struct Point));
}
\end{lstlisting}

Для создания временного файла предназначена функция \verb|tmpfile()|. Она возвращает файловый указатель на поток, открытый в режиме \verb|w+b|, или нулевой указатель в случае ошибки. После закрытия временный файл автоматически удаляется.

Идентификаторы \verb|stdin|, \verb|stdout| и \verb|stderr| являются файловыми указателями, связанными по умолчанию с окном консоли. Следовательно их можно использовать вместо обычных файлвых указателей в функциях, предназначенных для работы с файлами.

Вывести строку в окно консоли
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
fputs("String1\nString2", stdout);
fflush(stdout);
\end{lstlisting}

Пример вывода сообщения об ошибке в поток \verb|stderr|
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
fputs("Error message", stderr);
fflush(stderr);
\end{lstlisting}

С помощью \verb|fflush(fp)| можно сбросить буфер в файл \cite[\strbook{362}]{prokhorenok-prog-c:2020}.

\section{Потоки и процессы}

Если процессор является одноядерным, то будет происходить переключение между потоками, \emph{имитируя параллельное} выполнение. Потоки выполняются в рамках процесса и имеют общий доступ к его ресурсам, например глобальным переменным. Процесс содержит \emph{минимум один поток}, который создается \emph{при запуске} приложения. В этом \emph{основном потоке} выполняются инструкции, расположенные \emph{внутри тела} функции \verb|main()|. Помимо запуска задачи в отдельном потоке можно запустить задачу в отдельном процессе, которые будет выполняться параллельно или заменит текущий процесс.

Если \emph{несколько потоков} пытаются получить доступ \emph{к одному ресурсу}, то результат этого действия может стать \emph{непредсказуемым}. Для того чтобы не допустить проблем и избежать состояния гонок, необходимо выполнять \emph{синхронизацию} критичных секций (секций, к которым имеют доступ несколько потоков). При доступе к синхронизированной секции \emph{поток} \underline{\itshape запрашивает блокировку}. Если блокировка получена, то поток изменяет что-то внутри синхронизированного блока. Если не удалось получить блокировку, то поток блокируется до момента получения разрешения. {\color{blue}Таким образом, код внутри \emph{критичной секции} \underline{в один момент времени} выполняется \emph{только одним потоком} как атомарная операция} \cite[\strbook{412}]{prokhorenok-prog-c:2020}.

\remark{
Многие функции из стандартной библиотеки яызка Си не являются потокобезопасными. Можно пользоваться потокобезопасными функциями, объявленными  в заголовочном файле \texttt{strsfe.h}, а также функциями из WinAPI
}

Получив блокировку, можно выполнять инструкции внутри критической секции. После выхода из критической секции нужно обязательно снять блокировку, иначе секция будет заблокирована навсегда.

Вместо функции \verb|CreateThread()| из WinAPI для создания потока управления лучше использовать функцию \verb|_beginthreadex()|, объявленную в заголовочном файле \verb|process.h|, так как в этом случае внутри потока можно вызывать функции из стандартной библиотеки языка Си.

Дождаться завершения работы потока позволяет функция \verb|pthread_join()|.

\section{Создание библиотек}

\subsection{Статические библиотеки}

На первом этапе компиляции файл с исходным кодом преобразуется в объектный файл (файл с расширением \verb|.o|). Причем каждый файл с исходным кодом преобразуется отдельно. Этим достигается ускорение компиляции, так как нужно преобразовывать лишь файлы, которые были изменены, а не все файлы с исходным кодом. Так вот на втором этапе вместо EXE-файла можно создать статическую библиотеку.

\begin{lstlisting}[
title = {\sffamily module1.h},
style = c_cpp,
numbers = none	
]
#ifndef MODULE1_H_
#define MODULE1_H_
#ifdef __cplusplus
extern "C" {  // чтобы библиотеку можно было использовать в программах на C++
#endif

int sum_int(int x, int y);  // объявление функции

#ifdef __cplusplus
}
#endif

#endif /* MODULE1_H_ */
\end{lstlisting}

\begin{lstlisting}[
title = {\sffamily module1.c},
style = c_cpp,
numbers = none
]
#include "module1.h"  // подключение заголовочного файла проекта

int sum_int(int x, int y) {
    return x + y;
}
\end{lstlisting}

\begin{lstlisting}[
title = {\sffamily module2.h},
style = c_cpp,
numbers = none
]
#ifndef MODULE2_H_
#define MODULE2_H_

#ifdef __cplusplus
extern "C" {  // чтобы библиотеку можно было использовать в программах на C++
#endif

double sum_double(double x, double y);  // объявление функции

#ifdef __cplusplus
}
#endif

#endif /* MODULE2_H_ */
\end{lstlisting}

\begin{lstlisting}[
title = {\sffamily module2.c},
style = c_cpp,
numbers = none
]
#include "module2.h"  // подключение заголовочного файла проекта

double sum_double(double x, double y) {
    return x + y;
}
\end{lstlisting}

Чтобы библиотеку можно было использовать в программах на яызке С++, мы поместили объявления функций внутри следующего условия
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
#ifdef __cplusplus
extern "C" {
#endif

// Объявления функций и т.д.

#ifdef __cplusplus
}
#endif
\end{lstlisting}

Создать \emph{объектный файл} можно так
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
gcc -Wall -Wconversion -c -finput-charset=cp1251 -fexec-charset=cp1251 -o moduleX.o moduleX.c
\end{lstlisting}

Здесь флаг \verb|-c| нужен для создания объектых файлов, а флаг \verb|-o| для указания называния объектных файлов.

В результате компиляции были созданы два файла: \verb|module1.o| и \verb|module2.o|. Эти два объектных файла можно объединить в статическую библиотеку с помощью следующией команды
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
ar rcs lib<Название библиотеки.a> <Объектные файлы через пробел>
\end{lstlisting}

Программа \verb|ar.exe| создает архив, содержащий объектные файлы статической библиотеки. Пример
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
ar rcs libmodules_1_2.a module1.o module2.o
\end{lstlisting}

В результате в каталоге будет создан файл \verb|libmodules_1_2.a|. Теперь для того чтобы использовать полученную статитческую библиотеку, следует
\begin{lstlisting}[
title = {\sffamily test.c},
style = c_cpp,
numbers = none
]
#include <stdio.h>
#include <locale.h>
#include <module1.h>
#include <module2.h>

int main(void) {
    printf(sum_int(5, 10));
    printf(sum_double(3.125, 5.6));
}
\end{lstlisting}

Скомпилируем и запустим библиотеку
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
$ gcc -I~/C_projects/book/mylib/ -c test.c
$ gcc test.o -L
\end{lstlisting}

При использовании статических библиотек \emph{заголовочные файлы} обычно размещают в каталоге \verb|include|, а сами библиотеки -- в каталоге \verb|lib|.

Статические библиотеки становятся частью программы при компиляции, а динамические библиотеки подгружаются при запуске программы. В итоге размер программы при использовании статических библиотек будет больше размера программы, использующей динамические библиотеки.

Чтобы избежать проблем, лучше размещать статические и динамические библиотеки в каталогах с разными названиями (обычно \verb|lib| и \verb|bin|).

Перед компиляцией запускается специальная программа -- \emph{препроцессор}, которая подготавливает код к компиляции.







% Источники в "Газовой промышленности" нумеруются по мере упоминания 
\begin{thebibliography}{99}\addcontentsline{toc}{section}{Список литературы}
	
	\bibitem{podbelskiy-prog-c:2005}{ \emph{Подбельский В.В.}, \emph{Фомин С.С.} Прграммирование на языке Си, 2005. -- 600 с. }
	
	\bibitem{prokhorenok-prog-c:2020}{ \emph{Прохоренок Н.А.} Язык С. Самое необходимое. -- СПб.: БХВ-Петербург, 2020. -- 480 с. }
	
	\bibitem{amini-extreme-c:2022}{ \emph{Амини К.} Экстремальный Си. Параллелизм, ООП и продвинутые возможности. -- СПб.: Питер, 2022. -- 752 с. }
\end{thebibliography}

%\listoffigures\addcontentsline{toc}{section}{Список иллюстраций}

\lstlistoflistings\addcontentsline{toc}{section}{Список листингов}

\end{document}
