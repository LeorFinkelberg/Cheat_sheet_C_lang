\documentclass[%
	11pt,
	a4paper,
	utf8,
	%twocolumn
		]{article}	

\usepackage{style_packages/podvoyskiy_article_extended}


\begin{document}
\title{Приемы программирования на языке C}

\author{}

\date{}
\maketitle

\thispagestyle{fancy}

\tableofcontents

\section{Ресуры по языку Cи}

\url{https://learnc.info/c/}

\section{Вводные замечания}

Язык Си -- это компилируемый язык программирования высокого уровня, кроссплатформенный, позволяющий создавать программы которые будут работать во всех операционных системах, но для каждой операционной системы компиляцию нужно выполнять отдельно. 

Существует несколько стандартов языка Си: C90 (ANSI C/ISO C), C99 и C11. Для того чтобы использовать правила конкретного стандарта, нужно в составе команды компиляции указать следующие флаги: \verb*|-std=c90|, \verb|-std=c99| или \verb*|-std=c11|. Современный язык Си включает возможности стандарта С11.

Узнать используемый стандарт языка Си внутри программы можно с помощью \emph{макроса} \verb|__STDC_VERSION__|
\begin{lstlisting}[
style = c_cpp,
numbers = none	
]
printf("%ld\n", __STDC_VERSION__); // 201112
\end{lstlisting}

Получить информацию о версии компилятора позволяет макрос \verb*|__VERSION__|
\begin{lstlisting}[
style = c_cpp,
numbers = none	
]
printf("%s\n", __VERSION__); // Apple LLVM 12.0.0 (clang-1200.0.32.2)
\end{lstlisting}

Когда мы в командной строке вводим название программы без предварительного указания пути к ней, то
\begin{itemize}
	\item вначале поиск программы выполняется в текущем рабочем каталоге (обычно это каталог, из которого запускается программа),
	
	\item а затем в путях, указанных в системной переменной \verb|PATH|.
\end{itemize}

Системные каталоги имеют более высокий приоритет, чем каталоги, указанные в переменной \verb*|PATH|.

\section{Установка MSYS2 и MinGW-W64 для ОС Windows}

Установить компилятор \verb|gcc| на ОС Windows можно следующим образом. Детали процедуры установки можно найти в книге \cite[\strbook{24}]{prokhorenok-prog-c:2020}. Предварительно нам нужно установить библиотеку MSYS2. Переходим на сайт \url{https://www.msys2.org} и скачиваем файл \verb*|msys2-x86_64-20230718.exe|, а затем запускаем его.

Библиотека MSYS2 будет установлена в каталог \directory{C > msys64}. В этом каталоге расположены скрипты для запуска: \verb|msys2.exe|, \verb*|mingw32.exe|, \verb|mingw64.exe|.

Файл \verb*|msys2.exe| запускает командную строку, в которой мы можем установить различные библиотеки. Сначала обновим программу, выполнив команду
\begin{lstlisting}[
title = {\sffamily Окно msys2.exe},
style = bash,
numbers = none
]
$ pacman -Syu
\end{lstlisting}

Теперь можно установить библиотеку MinGW-W64
\begin{lstlisting}[
style = bash,
numbers = none
]
$ pacman -S mingw-w64-x86_64-toolchain
\end{lstlisting}

Для установки всех компонентов нажимаем клавишу \verb*|<Enter>|, а затем на запрос подтверждения установки вводим букву \verb|Y| и нажимаем клавишу \verb|<Enter>|.

Библиотека MinGW-W64 будет установлена в каталог \directory{C > msys64 > mingw64}. Добавив путь до \directory{C > msys64 > mingw64 > bin} в системную переменную \verb*|Path|, можно будет вызывать компилятор \verb|gcc| из любой точки
\begin{lstlisting}[
style = bash,
numbers = none
]
$ gcc --version
g++.exe (Rev2, Built by MSYS2 project) 13.2.0
...
\end{lstlisting}

Все установленные библиотеки скомпилированы под 64-битные операционные системы. Для установки 32-битных версий библиотек нужно в команде заменить фрагмент \verb*|x86_64| фрагментом \verb|i686|. Пример
\begin{lstlisting}[
style = bash,
numbers = none
]
$ pacman -S mingw-w64-i686-toolchain
\end{lstlisting}

\section{Приемы работы в редакторе Eclipse}

\subsection{Настройка редактора Eclipse}

Чтобы сделать иконки панели покрупнее, следует добавить в файл \verb|eclipse.ini| следующие строки
\begin{lstlisting}[
title = {\sffamily \$HOME/eclipse/cpp-2023-06/eclipse/eclipse.ini},
style = bash,
numbers = none
]
-Dswt.enable.autoScale=true
-Dswt.autoScale=150
-Dswt.autoScale.method=nearest
\end{lstlisting}

Чтобы редактор поддерживал Vim, следует в меню \menu{Help > Eclipse Markertplace} в строке Find вбить <<Vrapper>> и затем следовать инструкциям по установке.

\subsection{Сборка и запуск проекта}

Для того чтобы преобразовать текстовый файл \verb|Test64c.c| с программой в исполняемый exe-файл, делаем текущей вкладку с содержимым файла \verb|Test64c.c| и в меню \verb|Project| выбираем пункт \verb|Build Project|. В результате компиляции в рабочем каталоге будет создан каталог \directory{Debug}. Внутри этого каталога находится файл \verb|Test64c.exe|, который можно запустить на выполнение с помощью двойного щелчка мыши на значке файла.

Для запуска делаем текущей вкладку с содержимым файла \verb|Test64c.c| и в меню \verb|Run| выбираем пункт \verb|Run|. В открывшемся окне выбираем пункт \verb|Local C/C++ Application| и нажимаем кнопку \verb|OK|. Результат выполнения программы отобразится в окне \verb|Console|.

Простейший пример программы
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
#include <stdio.h>

int main(void) {
    printf("Hello, world");
    
    // в main() ключевое слово return можно не указывать
    return 0;
}
\end{lstlisting}

Здесь \verb|#include| -- это \emph{директива препроцессора}, с помощью которой включается файл \verb|stdio.h|, в котором есть функция \verb|printf()|, предназначенная для форматированного вывода данных в окно консоли. Так как название файла указано внутри угловых скобок, его поиск будет выполнен в \emph{путях поиска заголовочных файлов}.

Содержимое файла \verb|stdio.h| на одной из стадий компиляции целиком вставляется вместо инструкции с директивой \verb|#include|.

Функция \verb|printf()| содержится внутри файла \verb|stdio.h|, поэтому в первой строке программы мы включаем этот файл с помощью директивы \verb|#include|. Если заголовочный файл не включить, то функция будет недоступна.

После всех \emph{инструкций} указывается точка с запятой. Исключением являются \cite[\strbook{46}]{prokhorenok-prog-c:2020}:
\begin{itemize}
	\item \emph{составные инструкции} (в нашем примере после закрывающей фигурной скобки блока функции \verb|main()| точка с запятой не указывается)
	
	\item и \emph{директивы препроцессоров} (в нашем примере нет точки с запятой после инструкции с директивой \verb|#include|).
\end{itemize}

Согласно стандарту, внутри функции \verb|main()| ключевое слово \verb|return| можно не указывать. В этом случае компилятор должен самостоятельно вставить инструкцию, возвращающую значение~0 \cite[\strbook{46}]{prokhorenok-prog-c:2020}.

Программу можно скомпилировать и без редактора кода. Пример компиляции на ОС Windows
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
gcc -Wall -Wconversion -O3 -finput-charset=cp1251 -fexec-charset=cp1251 -o helloworld.exe helloworld.c
\end{lstlisting}

Первое слово (\verb|gcc|) вызывает компилятор \verb|gcc.exe|. Флаг \verb|-Wall| указывает выводить все предупреждающие сообщения, возникающие во время компиляции программы, флаг \verb|-Wconversion| задает вывод предупреждений при возможной потере данных, а флаг \verb|-O3| определяет уровень оптимизации. С помощью флага \verb|-finput-charset| указывается кодировка файла с программой, а с помощью флага \verb|-fexec-charset| -- кодировка C-строк. Название создаваемого в результате компиляции файла (\verb|helloworld.exe|) задается после флага \verb|-o|. Далее указывается название исходного текстового файла с программой на языке Си (\verb|helloworld.c|).

Помимо файлов с исходным кодом (имеют расширение \verb|*.c|) в проекте могут быть \emph{заголовочные файлы} (имеют расширение \verb|*.h|).

В заголовочных файлах указываются \emph{прототипы функций} и \emph{различные объявления}. Инструкции, начинающиеся с символа \verb|#|, -- это \emph{директивы препроцессора} \cite[\strbook{47}]{prokhorenok-prog-c:2020}.

Например для заголовчного файла с именем \verb|HelloWorld.h|
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
#ifndef HELLOWORLD_H_
#define HELLOWORLD_H_
#endif /* HELLOWORLD_H_ */
\end{lstlisting}

Здесь директива препроцессора \verb|#ifndef| проверяет отсутствие константы с именем \verb|HELLOWORLD_H_|, \verb|#define| -- создает константу с именем \verb|HELLOWORLD_H_|, а \verb|#endif| -- обозначает конец блока проверки отсутствия константы.

Заголовочный файл мы подключаем к файлу с исходным кодом (\verb|*.c|) с помощью директивы \verb|#include|: \verb|#include "HelloWorld.h"| (кавычки!!! а не угловые скобки). Встретив в исходном коде директиву \verb|#include|, \emph{компилятор} вставляет все содержимое заголовочного файла на место директивы. Если мы вставим две одинаковые директивы \verb|#include|, то содержимое заголовочного файла будет вставлено дважды. Чтобы этого избежать прототипы функций и прочие объявления вкладываются в блок, ограниченный директивами \verb|#ifndef| и \verb|#endif|. В директиве \verb|#ifndef| указывается константа, совпадающая с именем заголовочного файла. Все буквы в имени константы заглавные, а точка заменена символом подчеркивания. Если константа не существует (при первом включении так и будет), то с помощью директивы \verb|#define| эта константа создается и содержимое блока вставляется в исходный код. При повторном включении заголовочного файла константа уже существует, поэтому содержимое блока будет проигнорировано. Таким образом, заголовочный файл вставлен не будет, а значит, и ошибки не возникает.

Вместо этих директив в самом начале заголовчного файла можно указать директиву препроцессора \verb|#pragma| со значением \verb|once|, которая также препятствует повторному включению файла (в старых компиляторах директива может не поддреживаться)
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
#pragma once
// Объявление функций и пр.
\end{lstlisting}

Название заголовочного файла в директиве \verb|#include| может быть указано \cite[\strbook{51}]{prokhorenok-prog-c:2020}:
\begin{itemize}
	\item внутри угловых скобок \verb|#include <stdio.h>|,
	
	\item внутри кавычек \verb|#include "HelloWorld.h"|.
\end{itemize}

В первом случае заголовочный файл ищется в путях поиска заголовочных файлов. {При этом \emph{текущий рабочий каталог} \underline{не просматривается}}. Добавить каталог в пути поиска заголовочных файлов позволяет флаг \verb|-I| в команде компиляции. {\color{blue}Обычно с помощью \emph{угловых скобок} включаются заголовочные файлы \emph{стандратной библиотеки} или библиотеки \emph{стороннего разработчика}.}

Во втором случае мы имеем дело с заголовочным файлом, который \emph{вначале} ищется в \emph{текущем рабочем каталоге} (или относительно него), а \emph{затем в путях поиска заголовочных файлов}, как будто название указано внутри угловых скобок. {\color{blue}Таким способом (\verb|#include "HelloWorld.h"|) обычно включаются \emph{заголовочные файлы проекта.}}

Можно указать:
\begin{itemize}
	\item просто название заголовочного файла
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
#include "HelloWorld.h"
\end{lstlisting}

\item абсолютный путь к нему
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
#include "C:\\cpp\\projects\\HelloWorld\\src\\HelloWorld.h"
\end{lstlisting}

\item или относительный путь к нему
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
#include "./HelloWorld.h"
\end{lstlisting}
	
\end{itemize}

\subsection{Компиялция и запуск программы в редакторе Eclipse}

Компиляция в редакторе Eclipse выполняется в два прохода. При первом проходе создается объектный файл \verb|HelloWorld.o|, а на втором проходе на его основе создается исполняемый файл.

По умолчанию для проекта задается \emph{режим компиляции} \verb|Debug|. В этом режиме дополнительно сохраняется информация для отладчика, и EXE-файл будет создан \emph{без оптимизаций}. Когда программа уже написана и отлажена, нужно выбрать режим \verb|Realse|. Для этого в меню \verb|Project| выбираем пункт \menu{Build Configuration > Set Active > Release}.

В результате компиляции в разных режимах были созданы два EXE-файла -- в подкаталоге \verb|Debug| и в подкаталоге \verb|Release|. Первый файл содержит отладочную информацию, а второй -- нет. При компиляции второго была дополнительно выполнена оптимизация, поэтому именно этот файл нужно отдавать заказчику.






\section{Visual Studio Code как среда разработки для языка Cи}

Скачать Visual Studio Code можно здесь \url{https://code.visualstudio.com/}. Для ОС Windows нужно еще установить GCC. На ОС Linux компилятор gcc доступен <<из коробки>>. На ОС MacOS компилятор gcc можно установить с помщью утилиты \verb|brew|.

После установки IDE останется только создать директорию с проектом под язык Си. Когда Visual Studio Code увидит файл с расширением \verb|*.c|, она предложит установить специальное расширение <<C/C++ Extension Pack v1.X.X>>.

\section{Алфавит, идентификаторы, служебные слова}

Идентификаторы, начинающиеся с одного символа подчеркивания <<\verb|_|>> или с двух символов подчеркивания <<\verb*|__|>>, зарезервированы для использования в библиотеках и компиляторах. Поэтому такие идентификаторы не рекомендуется выбирать в качестве имен в прикладной программе на языке Си. Рекомендуется при программировании имена констант записывать целиком заглавными буквами \cite[\strbook{15}]{podbelskiy-prog-c:2005}.

\subsection{Константы и строки}

По определению, константа представляет значение, которое не может быть изменено. Синтаксис языка определяет 5 типов \emph{констант}:
\begin{enumerate}
	\item символы,
	
	\item константы перечисляемого типа,
	
	\item вещественные числа,
	
	\item целые числа,
	
	\item нулевой указатель (<<null>>-указатель).
\end{enumerate}

Управляющие последовательности (\verb*|'\n'|, \verb|'\r'|, etc.) являются частным случаем экскейп-последо\-вательностей (ESC-последовательностей), к которым также относятся лексемы вида \verb*|'\ddd'|, либо \verb|'\xhh'|.

\emph{Символьная константа} (символ) имеет \emph{целый тип}, то есть символы можно использовать в качестве целочисленных операндов в выражениях.

Целочисленные именованные константы можно вводить с помощью перечисления \verb*|enum|. Пример
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
enum DAY {SUNDAY, MONDAY, ...};
enum BOOLEAN {NO, YES};
\end{lstlisting}

В первой строке \verb*|DAY|, а во второй строке \verb|BOOLEAN| это необязательный произвольный идентификатор -- название перечисления.

Если в списке нет ни одного элемента со знаком \verb*|'='|, то значения констант начинаются с 0 и увеличиваются на 1 слева направо. Таким образом, \verb|NO| равно 0, а \verb*|YES| -- 1. Именованная константа со знаком \verb|'='| получает соответствующее значение, а следующая за ней именованные константы без явных значений увеличиваются на 1 каждая.

То есть если 
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
enum BOOLEAN {NO=10, YES};
printf("NO=%d, YES=%d", NO, YES);  // NO=10, YES=11
\end{lstlisting}

В Python можно сделать так
\begin{lstlisting}[
style = ironpython,
numbers = none	
]
from enum import Enum, auto

class Boolean(Enum):
    NO = 0
    YES = auto()
    
Boolean.NO.value  # 0
Boolean.YES.value  # 1
\end{lstlisting}

Формально строки не относятся к константам языка Си, а представляют собой отдельный тип его лексем. Строковая константа определяется как последовательность символов, заключенных в двойные кавычки (не в апострофы).

Представление \emph{строковых констант} в памяти ЭВМ подчиняются следующим правилам. Все символы строки размещаются подряд, и каждый символ (в том числе представленный эскейп-последовательностью) занимает ровно 1 байт. В конце записи строковой константы компилятор помещает символ \verb*|'\0'|.

Таким образом, количество байтов, выделяемое в памяти ЭВМ для представления значения строки, ровно на 1 больше, чем число символов в записи этой строковой константы.

При работе с символьной информацией нужно помнить, что длина символьной константы \verb*|'F'| равна 1 байту, а длина строки \verb|"F"| равна 2 байтам.

\subsection{Переменные и именованные константы}

Одним из основных понятий языка Си является \emph{объект} -- именованная область памяти. Частный случай объекта -- переменная.

Каждый из целочисленных типов (\verb|char|, \verb*|short|, \verb|int|, \verb*|long|) может быть определен либо как \emph{знаковый} \verb|signed| либо как \emph{беззнаковый} \verb*|unsigned| (по умолчанию \verb|signed|). 

Различие между этими двумя типами -- в правилах интерпретации \emph{старшего бита внутреннего представления}. Спецификатор \verb*|signed| означает, что старший бит внутреннего представления воспринимался как знаковый; \verb|unsigned| означает, что старший бит внутренного представления входит в код представляемого числового значения, которое считается в этом случае беззнаковым. Выбор знакового или беззнакового представления определяет предельные значения, которые можно представить с помощью описанной переменной. Например на IBM PC переменная типа \verb|unsigned int| позволяет представить числа от 0 до 65 535, а переменная типа \verb*|signed int| (или просто \verb*|int|) соответствуют значения в диапазоне от -32768 до +32767. 

Именованные константы можно вводить с помощью \emph{директивы препроцессора} \verb|#define|, напрмер
\begin{lstlisting}[
style = c_cpp,
numbers = none,
]
// препроцессорная константа
#define EULER 2.718282  // точка с запятой не нужна!!!
\end{lstlisting}

Что эквивалентно
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
const double EULER = 2.718282;
\end{lstlisting}

До начала компиляции текст программы на языке Си обрабатывается специальным компонентом транслятора -- \emph{препроцессором}. Далее текст от препроцессора поступает к компилятору. Итак, основное отличие констант, определяемых \emph{препроцессорными директивами} \verb*|#define|, состоит в том, что эти \emph{константы вводятся} в текст программы \emph{до этапа компиляции} -- препроцессор обрабатывает исходный код программы и делает в этом тексте замены и подстановки \cite[\strbook{29}]{podbelskiy-prog-c:2005}.

\section{Структура программы}

Программ состоит из инструкций, расположенных в текстовом файле
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
<Подключение заголовочных файлов>
<Объявление глобальных переменных>
<Объявление функций и пр.>
int main(void) {
    <Инструкции>
    return 0;
}
<Определения функций и пр.>
\end{lstlisting}

В самом начале программы подключаются \emph{заголовочные файлы}, в которых содержаться \emph{объявления} идентификаторов \underline{без их реализации}.

После подключения файлов производится \emph{объявление глобальных переменных}. \emph{Глобальные переменные} видны во всей программе, включая функции. Если объявить переменную внутри функции, то \emph{область видимости переменной} будет ограничена рамками функции и в других частях программы использовать переменную нельзя. Такие переменные называются \emph{локальными}

При объявлении переменной можно сразу присвоить начальное значение. Присваивание значения переменной при объявлении называется \emph{инициализацией переменной}
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
int x = 10;
int x = 21; int y = 85; int z = 56;
\end{lstlisting}

Если глобальной переменной не присвоено значение при объявлении, то она будет иметь значение 0. Если \emph{локальной} переменной не присвоено значение, то переменная будет содержать {\color{red}произвольное значение}. Как говорят в таком случае: переменная содержит <<мусор>> \cite[\strbook{59}]{prokhorenok-prog-c:2020}.

После директив препроцессора точка с запятой не указывается. В этом случае концом инструкции является конец строки. Директиву препроцессора можно узнать по символу \verb|#| перед названием директивы. 

После объявления глобальных переменных могут располагаться \emph{объявления функций}. Такие объявления называются \emph{прототипами}. Схема прототипа функции выглядит следующим образом
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
<Тип возвращаемого значения> <Название функции>(
    [<Тип> [<Параметр 1>]
    [, ..., <Тип> [<Параметр N>]]]);
\end{lstlisting}

Например, прототип функции, которая складывает два целых числа и возвращает их сумму, выглядит так
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
int sum(int x, int y);
\end{lstlisting}

После объявления функции необходимо описать ее реализацию, которая называется \emph{определением функции}. Определение функции обычно располагается после определения функции \verb|main()|. Обратите внимание на то, что объявлять прототип функции \verb|main()| не нужно.

Пример определения функции \verb|sum()|
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
int sum(int x, int y) {
    return x + y;
}
\end{lstlisting}

Первая строка в определении функции \verb|sum()| совпадает с объявлением функции. Следует заметить, что в объявлении функции можно не указывать названия параметров. Достаточно будет указать информацию о типе данных. Таким образом, объявление функции можно записать так
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
int sum(int, int);
\end{lstlisting}

После объявления функции ставится точка с запятой. Если функция не возвращает никакого значения, то перед названием функции вмето типа данных указывается ключевое слово \verb|void|. Пример объявления функции, которая не возвращает значения
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
void print(int);  // объявление функции; прототип

// определение функции, которая не возвращает значение
void print(int x) {
    printf("%d", x);
}
\end{lstlisting}

Самой главной функцией в программе является функция \verb|main()|. Именно функция с названием \verb|main()| будет автоматически вызываться при запуске программы. Функция имеет три прототипа
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
int main(void);
int main(int argc, char *argv[]);
int main(int argc, char *argv[], char **penv);
\end{lstlisting}

Значение \verb|void| внутри круглых скобок означает, что функция не принимает параметры. Второй прототип применяется для получения значений, указанных при запуске программы из командной строки. Количество значений доступно через параметр \verb|argc|, а сами значения через параметр \verb|argv|. Параметр \verb|penv| в третьем прототипе позволяет получить значения переменных окружения.

Ключевое слово \verb|int| означет, что функция возвращает целое число. Число 0 означает нормальное завершение программы. Если указано другое число, то это свидетельствует о некорретном завершении программы. Согласно стандрату, внутри функции \verb|main()| ключевое слово \verb|return| можно не указывать. В этом случае компилятор должен самостоятельно вставить инструкцию, возвращающую значение 0. Возвращаемое значение передается операционной системе и может использоваться для определения корректности завершения программы.

Вместо безликого значения 0 можно воспользоваться макроопределением \verb|EXIT_SUCCESS|, а для индикации некорректного завершения программы -- макроопределением \verb|EXIT_FAILURE|. Предварительно необходимо включить заголовочный файл \verb|stdlib.h|.







% Источники в "Газовой промышленности" нумеруются по мере упоминания 
\begin{thebibliography}{99}\addcontentsline{toc}{section}{Список литературы}
	
	\bibitem{podbelskiy-prog-c:2005}{ \emph{Подбельский В.В.}, \emph{Фомин С.С.} Прграммирование на языке Си, 2005. -- 600 с. }
	
		\bibitem{prokhorenok-prog-c:2020}{ \emph{Прохоренок Н.А.} Язык С. Самое необходимое. -- СПб.: БХВ-Петербург, 2020. -- 480 с. }
\end{thebibliography}

%\listoffigures\addcontentsline{toc}{section}{Список иллюстраций}

\lstlistoflistings\addcontentsline{toc}{section}{Список листингов}

\end{document}
