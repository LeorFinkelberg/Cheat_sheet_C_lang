\documentclass[%
	11pt,
	a4paper,
	utf8,
	%twocolumn
		]{article}	

\usepackage{style_packages/podvoyskiy_article_extended}


\begin{document}
\title{Приемы программирования на языке C}

\author{}

\date{}
\maketitle

\thispagestyle{fancy}

\tableofcontents

\section{Ресуры по языку Cи}

\url{https://learnc.info/c/}

\section{Вводные замечания}

Язык Си -- это компилируемый язык программирования высокого уровня, кроссплатформенный, позволяющий создавать программы которые будут работать во всех операционных системах, но для каждой операционной системы компиляцию нужно выполнять отдельно. 

Существует несколько стандартов языка Си: C90 (ANSI C/ISO C), C99 и C11. Для того чтобы использовать правила конкретного стандарта, нужно в составе команды компиляции указать следующие флаги: \verb*|-std=c90|, \verb|-std=c99| или \verb*|-std=c11|. Современный язык Си включает возможности стандарта С11.

Узнать используемый стандарт языка Си внутри программы можно с помощью \emph{макроса} \verb|__STDC_VERSION__|
\begin{lstlisting}[
style = c_cpp,
numbers = none	
]
printf("%ld\n", __STDC_VERSION__); // 201112
\end{lstlisting}

Получить информацию о версии компилятора позволяет макрос \verb*|__VERSION__|
\begin{lstlisting}[
style = c_cpp,
numbers = none	
]
printf("%s\n", __VERSION__); // Apple LLVM 12.0.0 (clang-1200.0.32.2)
\end{lstlisting}

Когда мы в командной строке вводим название программы без предварительного указания пути к ней, то
\begin{itemize}
	\item вначале поиск программы выполняется в текущем рабочем каталоге (обычно это каталог, из которого запускается программа),
	
	\item а затем в путях, указанных в системной переменной \verb|PATH|.
\end{itemize}

Системные каталоги имеют более высокий приоритет, чем каталоги, указанные в переменной \verb*|PATH|.

\section{Установка MSYS2 и MinGW-W64 для ОС Windows}

Установить компилятор \verb|gcc| на ОС Windows можно следующим образом. Детали процедуры установки можно найти в книге \cite[\strbook{24}]{prokhorenok-prog-c:2020}. Предварительно нам нужно установить библиотеку MSYS2. Переходим на сайт \url{https://www.msys2.org} и скачиваем файл \verb*|msys2-x86_64-20230718.exe|, а затем запускаем его.

Библиотека MSYS2 будет установлена в каталог \directory{C > msys64}. В этом каталоге расположены скрипты для запуска: \verb|msys2.exe|, \verb*|mingw32.exe|, \verb|mingw64.exe|.

Файл \verb*|msys2.exe| запускает командную строку, в которой мы можем установить различные библиотеки. Сначала обновим программу, выполнив команду
\begin{lstlisting}[
title = {\sffamily Окно msys2.exe},
style = bash,
numbers = none
]
$ pacman -Syu
\end{lstlisting}

Теперь можно установить библиотеку MinGW-W64
\begin{lstlisting}[
style = bash,
numbers = none
]
$ pacman -S mingw-w64-x86_64-toolchain
\end{lstlisting}

Для установки всех компонентов нажимаем клавишу \verb*|<Enter>|, а затем на запрос подтверждения установки вводим букву \verb|Y| и нажимаем клавишу \verb|<Enter>|.

Библиотека MinGW-W64 будет установлена в каталог \directory{C > msys64 > mingw64}. Добавив путь до \directory{C > msys64 > mingw64 > bin} в системную переменную \verb*|Path|, можно будет вызывать компилятор \verb|gcc| из любой точки
\begin{lstlisting}[
style = bash,
numbers = none
]
$ gcc --version
g++.exe (Rev2, Built by MSYS2 project) 13.2.0
...
\end{lstlisting}

Все установленные библиотеки скомпилированы под 64-битные операционные системы. Для установки 32-битных версий библиотек нужно в команде заменить фрагмент \verb*|x86_64| фрагментом \verb|i686|. Пример
\begin{lstlisting}[
style = bash,
numbers = none
]
$ pacman -S mingw-w64-i686-toolchain
\end{lstlisting}

\section{Приемы работы в редакторе Eclipse}

\subsection{Настройка редактора Eclipse}

Чтобы сделать иконки панели покрупнее, следует добавить в файл \verb|eclipse.ini| следующие строки
\begin{lstlisting}[
title = {\sffamily \$HOME/eclipse/cpp-2023-06/eclipse/eclipse.ini},
style = bash,
numbers = none
]
-Dswt.enable.autoScale=true
-Dswt.autoScale=150
-Dswt.autoScale.method=nearest
\end{lstlisting}

Чтобы редактор поддерживал Vim, следует в меню \menu{Help > Eclipse Markertplace} в строке Find вбить <<Vrapper>> и затем следовать инструкциям по установке.

\subsection{Сборка и запуск проекта}

Для того чтобы преобразовать текстовый файл \verb|Test64c.c| с программой в исполняемый exe-файл, делаем текущей вкладку с содержимым файла \verb|Test64c.c| и в меню \verb|Project| выбираем пункт \verb|Build Project|. В результате компиляции в рабочем каталоге будет создан каталог \directory{Debug}. Внутри этого каталога находится файл \verb|Test64c.exe|, который можно запустить на выполнение с помощью двойного щелчка мыши на значке файла.

Для запуска делаем текущей вкладку с содержимым файла \verb|Test64c.c| и в меню \verb|Run| выбираем пункт \verb|Run|. В открывшемся окне выбираем пункт \verb|Local C/C++ Application| и нажимаем кнопку \verb|OK|. Результат выполнения программы отобразится в окне \verb|Console|.

Простейший пример программы
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
#include <stdio.h>

int main(void) {
    printf("Hello, world");
    
    // в main() ключевое слово return можно не указывать
    return 0;
}
\end{lstlisting}

Здесь \verb|#include| -- это \emph{директива препроцессора}, с помощью которой включается файл \verb|stdio.h|, в котором есть функция \verb|printf()|, предназначенная для форматированного вывода данных в окно консоли. Так как название файла указано внутри угловых скобок, его поиск будет выполнен в \emph{путях поиска заголовочных файлов}.

Содержимое файла \verb|stdio.h| на одной из стадий компиляции целиком вставляется вместо инструкции с директивой \verb|#include|.

Функция \verb|printf()| содержится внутри файла \verb|stdio.h|, поэтому в первой строке программы мы включаем этот файл с помощью директивы \verb|#include|. Если заголовочный файл не включить, то функция будет недоступна.

После всех \emph{инструкций} указывается точка с запятой. Исключением являются \cite[\strbook{46}]{prokhorenok-prog-c:2020}:
\begin{itemize}
	\item \emph{составные инструкции} (в нашем примере после закрывающей фигурной скобки блока функции \verb|main()| точка с запятой не указывается)
	
	\item и \emph{директивы препроцессоров} (в нашем примере нет точки с запятой после инструкции с директивой \verb|#include|).
\end{itemize}

Согласно стандарту, внутри функции \verb|main()| ключевое слово \verb|return| можно не указывать. В этом случае компилятор должен самостоятельно вставить инструкцию, возвращающую значение~0 \cite[\strbook{46}]{prokhorenok-prog-c:2020}.

Программу можно скомпилировать и без редактора кода. Пример компиляции на ОС Windows
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
gcc -Wall -Wconversion -O3 -finput-charset=cp1251 -fexec-charset=cp1251 -o helloworld.exe helloworld.c
\end{lstlisting}

Первое слово (\verb|gcc|) вызывает компилятор \verb|gcc.exe|. Флаг \verb|-Wall| указывает выводить все предупреждающие сообщения, возникающие во время компиляции программы, флаг \verb|-Wconversion| задает вывод предупреждений при возможной потере данных, а флаг \verb|-O3| определяет уровень оптимизации. С помощью флага \verb|-finput-charset| указывается кодировка файла с программой, а с помощью флага \verb|-fexec-charset| -- кодировка C-строк. Название создаваемого в результате компиляции файла (\verb|helloworld.exe|) задается после флага \verb|-o|. Далее указывается название исходного текстового файла с программой на языке Си (\verb|helloworld.c|).

Помимо файлов с исходным кодом (имеют расширение \verb|*.c|) в проекте могут быть \emph{заголовочные файлы} (имеют расширение \verb|*.h|).

В заголовочных файлах указываются \emph{прототипы функций} и \emph{различные объявления}. Инструкции, начинающиеся с символа \verb|#|, -- это \emph{директивы препроцессора} \cite[\strbook{47}]{prokhorenok-prog-c:2020}.

Например для заголовчного файла с именем \verb|HelloWorld.h|
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
#ifndef HELLOWORLD_H_
#define HELLOWORLD_H_
#endif /* HELLOWORLD_H_ */
\end{lstlisting}

Здесь директива препроцессора \verb|#ifndef| проверяет отсутствие константы с именем \verb|HELLOWORLD_H_|, \verb|#define| -- создает константу с именем \verb|HELLOWORLD_H_|, а \verb|#endif| -- обозначает конец блока проверки отсутствия константы.

Заголовочный файл мы подключаем к файлу с исходным кодом (\verb|*.c|) с помощью директивы \verb|#include|: \verb|#include "HelloWorld.h"| (кавычки!!! а не угловые скобки). Встретив в исходном коде директиву \verb|#include|, \emph{компилятор} вставляет все содержимое заголовочного файла на место директивы. Если мы вставим две одинаковые директивы \verb|#include|, то содержимое заголовочного файла будет вставлено дважды. Чтобы этого избежать прототипы функций и прочие объявления вкладываются в блок, ограниченный директивами \verb|#ifndef| и \verb|#endif|. В директиве \verb|#ifndef| указывается константа, совпадающая с именем заголовочного файла. Все буквы в имени константы заглавные, а точка заменена символом подчеркивания. Если константа не существует (при первом включении так и будет), то с помощью директивы \verb|#define| эта константа создается и содержимое блока вставляется в исходный код. При повторном включении заголовочного файла константа уже существует, поэтому содержимое блока будет проигнорировано. Таким образом, заголовочный файл вставлен не будет, а значит, и ошибки не возникает.

Вместо этих директив в самом начале заголовчного файла можно указать директиву препроцессора \verb|#pragma| со значением \verb|once|, которая также препятствует повторному включению файла (в старых компиляторах директива может не поддреживаться)
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
#pragma once
// Объявление функций и пр.
\end{lstlisting}

Название заголовочного файла в директиве \verb|#include| может быть указано \cite[\strbook{51}]{prokhorenok-prog-c:2020}:
\begin{itemize}
	\item внутри угловых скобок \verb|#include <stdio.h>|,
	
	\item внутри кавычек \verb|#include "HelloWorld.h"|.
\end{itemize}

В первом случае заголовочный файл ищется в путях поиска заголовочных файлов. {При этом \emph{текущий рабочий каталог} \underline{не просматривается}}. Добавить каталог в пути поиска заголовочных файлов позволяет флаг \verb|-I| в команде компиляции. {\color{blue}Обычно с помощью \emph{угловых скобок} включаются заголовочные файлы \emph{стандратной библиотеки} или библиотеки \emph{стороннего разработчика}.}

Во втором случае мы имеем дело с заголовочным файлом, который \emph{вначале} ищется в \emph{текущем рабочем каталоге} (или относительно него), а \emph{затем в путях поиска заголовочных файлов}, как будто название указано внутри угловых скобок. {\color{blue}Таким способом (\verb|#include "HelloWorld.h"|) обычно включаются \emph{заголовочные файлы проекта.}}

Можно указать:
\begin{itemize}
	\item просто название заголовочного файла
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
#include "HelloWorld.h"
\end{lstlisting}

\item абсолютный путь к нему
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
#include "C:\\cpp\\projects\\HelloWorld\\src\\HelloWorld.h"
\end{lstlisting}

\item или относительный путь к нему
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
#include "./HelloWorld.h"
\end{lstlisting}
	
\end{itemize}

\subsection{Компиялция и запуск программы в редакторе Eclipse}

Компиляция в редакторе Eclipse выполняется в два прохода. При первом проходе создается объектный файл \verb|HelloWorld.o|, а на втором проходе на его основе создается исполняемый файл.

По умолчанию для проекта задается \emph{режим компиляции} \verb|Debug|. В этом режиме дополнительно сохраняется информация для отладчика, и EXE-файл будет создан \emph{без оптимизаций}. Когда программа уже написана и отлажена, нужно выбрать режим \verb|Realse|. Для этого в меню \verb|Project| выбираем пункт \menu{Build Configuration > Set Active > Release}.

В результате компиляции в разных режимах были созданы два EXE-файла -- в подкаталоге \verb|Debug| и в подкаталоге \verb|Release|. Первый файл содержит отладочную информацию, а второй -- нет. При компиляции второго была дополнительно выполнена оптимизация, поэтому именно этот файл нужно отдавать заказчику.






\section{Visual Studio Code как среда разработки для языка Cи}

Скачать Visual Studio Code можно здесь \url{https://code.visualstudio.com/}. Для ОС Windows нужно еще установить GCC. На ОС Linux компилятор gcc доступен <<из коробки>>. На ОС MacOS компилятор gcc можно установить с помщью утилиты \verb|brew|.

После установки IDE останется только создать директорию с проектом под язык Си. Когда Visual Studio Code увидит файл с расширением \verb|*.c|, она предложит установить специальное расширение <<C/C++ Extension Pack v1.X.X>>.

\section{Алфавит, идентификаторы, служебные слова}

Идентификаторы, начинающиеся с одного символа подчеркивания <<\verb|_|>> или с двух символов подчеркивания <<\verb*|__|>>, зарезервированы для использования в библиотеках и компиляторах. Поэтому такие идентификаторы не рекомендуется выбирать в качестве имен в прикладной программе на языке Си. Рекомендуется при программировании имена констант записывать целиком заглавными буквами \cite[\strbook{15}]{podbelskiy-prog-c:2005}.

\subsection{Константы и строки}

По определению, константа представляет значение, которое не может быть изменено. Синтаксис языка определяет 5 типов \emph{констант}:
\begin{enumerate}
	\item символы,
	
	\item константы перечисляемого типа,
	
	\item вещественные числа,
	
	\item целые числа,
	
	\item нулевой указатель (<<null>>-указатель).
\end{enumerate}

Управляющие последовательности (\verb*|'\n'|, \verb|'\r'|, etc.) являются частным случаем экскейп-последо\-вательностей (ESC-последовательностей), к которым также относятся лексемы вида \verb*|'\ddd'|, либо \verb|'\xhh'|.

\emph{Символьная константа} (символ) имеет \emph{целый тип}, то есть символы можно использовать в качестве целочисленных операндов в выражениях.

Целочисленные именованные константы можно вводить с помощью перечисления \verb*|enum|. Пример
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
enum DAY {SUNDAY, MONDAY, ...};
enum BOOLEAN {NO, YES};
\end{lstlisting}

В первой строке \verb*|DAY|, а во второй строке \verb|BOOLEAN| это необязательный произвольный идентификатор -- название перечисления.

Если в списке нет ни одного элемента со знаком \verb*|'='|, то значения констант начинаются с 0 и увеличиваются на 1 слева направо. Таким образом, \verb|NO| равно 0, а \verb*|YES| -- 1. Именованная константа со знаком \verb|'='| получает соответствующее значение, а следующая за ней именованные константы без явных значений увеличиваются на 1 каждая.

То есть если 
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
enum BOOLEAN {NO=10, YES};
printf("NO=%d, YES=%d", NO, YES);  // NO=10, YES=11
\end{lstlisting}

В Python можно сделать так
\begin{lstlisting}[
style = ironpython,
numbers = none	
]
from enum import Enum, auto

class Boolean(Enum):
    NO = 0
    YES = auto()
    
Boolean.NO.value  # 0
Boolean.YES.value  # 1
\end{lstlisting}

Формально строки не относятся к константам языка Си, а представляют собой отдельный тип его лексем. Строковая константа определяется как последовательность символов, заключенных в двойные кавычки (не в апострофы).

Представление \emph{строковых констант} в памяти ЭВМ подчиняются следующим правилам. Все символы строки размещаются подряд, и каждый символ (в том числе представленный эскейп-последовательностью) занимает ровно 1 байт. В конце записи строковой константы компилятор помещает символ \verb*|'\0'|.

Таким образом, количество байтов, выделяемое в памяти ЭВМ для представления значения строки, ровно на 1 больше, чем число символов в записи этой строковой константы.

При работе с символьной информацией нужно помнить, что длина символьной константы \verb*|'F'| равна 1 байту, а длина строки \verb|"F"| равна 2 байтам.

\subsection{Переменные и именованные константы}

Одним из основных понятий языка Си является \emph{объект} -- именованная область памяти. Частный случай объекта -- переменная.

Каждый из целочисленных типов (\verb|char|, \verb*|short|, \verb|int|, \verb*|long|) может быть определен либо как \emph{знаковый} \verb|signed| либо как \emph{беззнаковый} \verb*|unsigned| (по умолчанию \verb|signed|). 

Различие между этими двумя типами -- в правилах интерпретации \emph{старшего бита внутреннего представления}. Спецификатор \verb*|signed| означает, что старший бит внутреннего представления воспринимался как знаковый; \verb|unsigned| означает, что старший бит внутренного представления входит в код представляемого числового значения, которое считается в этом случае беззнаковым. Выбор знакового или беззнакового представления определяет предельные значения, которые можно представить с помощью описанной переменной. Например на IBM PC переменная типа \verb|unsigned int| позволяет представить числа от 0 до 65 535, а переменная типа \verb*|signed int| (или просто \verb*|int|) соответствуют значения в диапазоне от -32768 до +32767. 

Именованные константы можно вводить с помощью \emph{директивы препроцессора} \verb|#define|, напрмер
\begin{lstlisting}[
style = c_cpp,
numbers = none,
]
// препроцессорная константа
#define EULER 2.718282  // точка с запятой не нужна!!!
\end{lstlisting}

Что эквивалентно
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
const double EULER = 2.718282;
\end{lstlisting}

До начала компиляции текст программы на языке Си обрабатывается специальным компонентом транслятора -- \emph{препроцессором}. Далее текст от препроцессора поступает к компилятору. Итак, основное отличие констант, определяемых \emph{препроцессорными директивами} \verb*|#define|, состоит в том, что эти \emph{константы вводятся} в текст программы \emph{до этапа компиляции} -- препроцессор обрабатывает исходный код программы и делает в этом тексте замены и подстановки \cite[\strbook{29}]{podbelskiy-prog-c:2005}.

\section{Структура программы}

Программ состоит из инструкций, расположенных в текстовом файле
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
<Подключение заголовочных файлов>
<Объявление глобальных переменных>
<Объявление функций и пр.>
int main(void) {
    <Инструкции>
    return 0;
}
<Определения функций и пр.>
\end{lstlisting}

В самом начале программы подключаются \emph{заголовочные файлы}, в которых содержаться \emph{объявления} идентификаторов \underline{без их реализации}.

После подключения файлов производится \emph{объявление глобальных переменных}. \emph{Глобальные переменные} видны во всей программе, включая функции. Если объявить переменную внутри функции, то \emph{область видимости переменной} будет ограничена рамками функции и в других частях программы использовать переменную нельзя. Такие переменные называются \emph{локальными}

При объявлении переменной можно сразу присвоить начальное значение. Присваивание значения переменной при объявлении называется \emph{инициализацией переменной}
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
int x = 10;
int x = 21; int y = 85; int z = 56;
\end{lstlisting}

Если глобальной переменной не присвоено значение при объявлении, то она будет иметь значение 0. Если \emph{локальной} переменной не присвоено значение, то переменная будет содержать {\color{red}произвольное значение}. Как говорят в таком случае: переменная содержит <<мусор>> \cite[\strbook{59}]{prokhorenok-prog-c:2020}.

После директив препроцессора точка с запятой не указывается. В этом случае концом инструкции является конец строки. Директиву препроцессора можно узнать по символу \verb|#| перед названием директивы. 

После объявления глобальных переменных могут располагаться \emph{объявления функций}. Такие объявления называются \emph{прототипами}. Схема прототипа функции выглядит следующим образом
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
<Тип возвращаемого значения> <Название функции>(
    [<Тип> [<Параметр 1>]
    [, ..., <Тип> [<Параметр N>]]]);
\end{lstlisting}

Например, прототип функции, которая складывает два целых числа и возвращает их сумму, выглядит так
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
int sum(int x, int y);
\end{lstlisting}

После объявления функции необходимо описать ее реализацию, которая называется \emph{определением функции}. Определение функции обычно располагается после определения функции \verb|main()|. Обратите внимание на то, что объявлять прототип функции \verb|main()| не нужно.

Пример определения функции \verb|sum()|
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
int sum(int x, int y) {
    return x + y;
}
\end{lstlisting}

Первая строка в определении функции \verb|sum()| совпадает с объявлением функции. Следует заметить, что в объявлении функции можно не указывать названия параметров. Достаточно будет указать информацию о типе данных. Таким образом, объявление функции можно записать так
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
int sum(int, int);
\end{lstlisting}

После объявления функции ставится точка с запятой. Если функция не возвращает никакого значения, то перед названием функции вмето типа данных указывается ключевое слово \verb|void|. Пример объявления функции, которая не возвращает значения
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
void print(int);  // объявление функции; прототип

// определение функции, которая не возвращает значение
void print(int x) {
    printf("%d", x);
}
\end{lstlisting}

Самой главной функцией в программе является функция \verb|main()|. Именно функция с названием \verb|main()| будет автоматически вызываться при запуске программы. Функция имеет три прототипа
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
int main(void);
int main(int argc, char *argv[]);
int main(int argc, char *argv[], char **penv);
\end{lstlisting}

Значение \verb|void| внутри круглых скобок означает, что функция не принимает параметры. Второй прототип применяется для получения значений, указанных при запуске программы из командной строки. Количество значений доступно через параметр \verb|argc|, а сами значения через параметр \verb|argv|. Параметр \verb|penv| в третьем прототипе позволяет получить значения переменных окружения.

Ключевое слово \verb|int| означет, что функция возвращает целое число. Число 0 означает нормальное завершение программы. Если указано другое число, то это свидетельствует о некорретном завершении программы. Согласно стандрату, внутри функции \verb|main()| ключевое слово \verb|return| можно не указывать. В этом случае компилятор должен самостоятельно вставить инструкцию, возвращающую значение 0. Возвращаемое значение передается операционной системе и может использоваться для определения корректности завершения программы.

Вместо безликого значения 0 можно воспользоваться макроопределением \verb|EXIT_SUCCESS|, а для индикации некорректного завершения программы -- макроопределением \verb|EXIT_FAILURE|. Предварительно необходимо включить заголовочный файл \verb|stdlib.h|.

Пример программы
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
// Включение заголовочных файлов
#include <stdio.h>
#include <stdlib.h>

// Объявление глобальных переменных
int x = 21;
int y = 85;

// Объявление функций и пр.
int sum(int, int);
void print(int);

// Главная функция (точка входа в программу)
int main(void) {
    int z;
    z = sum(x, y);
    print(z);
    return EXIT_SUCCESS;
}

// Определение функций
int sum(int x, int y) {
    return x + y;
}

void print(int x) {
    printf("%d", x);
}
\end{lstlisting}

Объявление функций можно вынести в отдельный заголовочный файл и включить его с помощью директивы \verb|#include|
\begin{lstlisting}[
title = {\sffamily MyPrototypes.h},
style = c_cpp,
numbers = none
]
#ifndef MYPROTOTYPES_H_
#define MYPROTOTYPES_H_

// Объявление функций и пр.
int sum(int x, int y);

#endif /* MYPROTOTYPES_H_ */
\end{lstlisting}

Директивы препроцессора \verb|#ifndef|, \verb|#define| и \verb|#endif| препятствуют повторному включению заголовочного файла. Вместо этих директив можно указать в самом начале файла директиву препроцессора \verb|#pragma| со значением \verb|once|, то есть
\begin{lstlisting}[
title = {\sffamily MyPrototypes.h},
style = c_cpp,
numbers = none
]
#pragma once

// Объявление функций и пр.
int sum(int x, int y);
\end{lstlisting}

\section{Ввод / вывод}

\subsection{Вывод данных}

Для вывода одиночного символа в языке Си применяется функция \verb*|putchar()|: \verb|putchar('w');| Вывести строку позволяет функция \verb*|puts()|, которая выводит строку и вставляет символ перевода строки: \verb|puts("String);|.

Для форматированного выводв используется функция \verb*|printf()|. Можно также воспользоваться функцией \verb|_printf_l()|, которая позволяет дополнительно задать локаль. Функции \verb*|printf()| можно передавать обычные символы и спецификаторы формата, начинающиеся с символа \verb|%|
\begin{lstlisting}[
style = c_cpp,
numbers = none	
]
printf("String\n");
printf("Count %d\n", 10);  // спецификатор формата %d
printf("%s %d\n", "Count", 10);  // спецификаторы формат %s и %d
\end{lstlisting}

NB: \emph{Тип данных} переданных \emph{значений} \underline{должен совпадать} с \emph{типом спецификатора}. Если, например, в качестве значения для спецификатора \verb*|%s| указать число, то это приведет к ошибке времени выполнения.

Спецификаторы имеют следующий синтаксис \cite[\strbook{66}]{prokhorenok-prog-c:2020}
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
%[<Флаги>][<Ширина]>[.<Точность>][<Размер>]<Тип>
\end{lstlisting}

В параметре \verb|<Тип>| могут быть указаны следующие символы:
\begin{itemize}
	\item \verb*|c| -- символ: \verb|printf("%c", 'w');|
	
	\item \verb*|s| -- строка: \verb|printf("%s", "String");|
	
	\item \verb*|d| или \verb|i| -- десятичное целое со знаком: \verb|printf("%d %i", 10, 30);|
	
	\item \verb|u| -- десятичное целое без знака: \verb|printf("%u", 10);|
	
	\item \verb|o| -- восмеричное число без знака: \verb|printf("%#o %#o", 10, 77);|
	
	\item \verb|x| -- шестнадцатиричное число без знака в нижнем регистре: \verb|printf("%#x %#x", 10, 0xff);|
	
	\item \verb|f| -- вещественное число в десятичном представлении: \verb|printf("%#.0f %.0f", 100.0, 100.0);|
	
	\item \verb*|e| -- вещественное число в экспоненциальной форме: \verb|printf("%e", 18657.81452);|
	
	\item \verb|g| -- эквивалентно \verb*|f| или \verb|e| (выбирается более короткая запись числа):\\ \verb|printf("%g %g %g", 0.086578, 0.000086578, 1.865E-05);|
	
	\item \verb|p| -- вывод адреса переменной: \verb|printf("%p", &x);|
	
	\item \verb*|%| -- символ процента: \verb|printf("10%%");|
\end{itemize}

Параметр \verb|<Ширина>| задает минимальную ширину поля. Если строка меньше ширины поля, то она дополняется пробелами. Если строка не помещается в указанную ширину, то значение игнорируется и строка выводится полностью:
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
printf("'%3s", "string"); // 'string'
printf("%10s", "string"); // '    string'
\end{lstlisting}

Параметр \verb*|<Точность>| задает количество знаков после точки для вещественных чисел. Перед этим параметром обязательно должна стоять точка. Пример
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
printf("'%10.5f'", 3.1445454545);  // '   3.14454'
printf("'%.3f'", 3.1434534545);  // '3.143'
\end{lstlisting}

Вместо минимальной ширины и точности можно указывать символ \verb*|*|. В этом случае значения передаются через параметры функции \verb*|printf()| в порядке указания символов в строке формата.

В параметре \verb|<Флаги>| могут быть указаны следующие символы:
\begin{itemize}
	\item \verb*|#| -- для восьмиричных значений добавляет в начало символ 0, для шестнадцатиричных значений добавляет комбинацию символов \verb|0x| (если используется тип \verb*|x|) или \verb|0X| (если используется тип \verb*|X|), для вещественных чисел указывает всегда выводить дробную точку, даже если задано значение 0 в параметре \verb|<Точность>|.
	
	\item \verb*|0| -- задает наличие ведущих нулей для числового значения,
	
	\item \verb|-| -- задает выравнивание по левой границе области. По умолчанию используется выравнивание по правой границе: \verb|printf("'%-5d'", 3);|
	
	\item \verb|пробел| -- вставляет пробел перед положительным числом. Перед отрицательным числом будет стоять минус.
	
	\item \verb*|+| -- задает обязательный вывод знака как для отрицательных, так и для положительных чисел.
\end{itemize}

\subsection{Ввод данных}

Для ввода одного символа предназначена функция \verb*|getchar()|. В качестве значения фукнция возвращает код введенного символа.

Для получения и \emph{автоматического преобразования данных в конкретный тип} (например, в целое число) предназначена функция \verb*|scanf()|. При вводе строки функция не производит никакой проверки длины строки, что может привести к переполнению буфера. Функция возвращает количество произведенных присваиваний.

NB: Чтобы избежать переполнения буфера, обязательно указываейте \emph{ширину} при использовании спецификатора \verb*|%s| (например, \verb|%255s|).

\begin{lstlisting}[
style = c_cpp,
numbers = none
]
int x = 0;

printf("Enter number: ");
fflush(stdout);
fflush(stdin);

int status = scanf("%d", &x);  // &x -- адрес переменной 'x', а не ее значение!
if (status == 1) {
    printf("You entered: %d\n", x);
} else {
    puts("Error!);
}

printf("status = %d\n", status);
\end{lstlisting}

То есть конструкция в языке Си
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
float x = 0.0;
printf("Enter number: ");
scanf("%f", &x);  // адрес переменной x
\end{lstlisting}
это то же самое, что в Python конструкция
\begin{lstlisting}[
style = ironpython,
numbers = none
]
x = float(input("Enter number: "))
\end{lstlisting}

Если ожидается строка, то символ \verb*|&| указывать не следует, так как имя переменной в случае строки это ссылка на первый элемент массива символов
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
char word[255] = "";
printf("Enter word: ");
fflush(stdout);  // сброс буфера вывода в консоль
fflush(stdin);  // очистка буфера ввода
// пользовательский ввод будет обрезан до 255 символов
scanf("%255s", word);  // %255s чтобы избежать переполнения буфера

printf("You entered: %s", word);
\end{lstlisting}

Функция \verb|fflush(stdout)| сбрасывает данные из буфера потока вывода \verb*|stdout| в консоль. Если \emph{буфер вывода} принудительно не сбросить, пользователь может не увидеть подсказку вообще \cite[\strbook{74}]{prokhorenok-prog-c:2020}.

Функция \verb*|fflush(stdin)| очищает буфер потока ввода \verb|stdin|. Если не очистить \emph{буфер ввода} перед повторным получением числа, то это число может быть получено из предыдущего ввода из буфера. Например, при запросе первого числа было введено значение \verb*|"47 3"|. Функция \verb|scanf()| получит число 47, а второе число оставит в буфере, и оно будет доступно для следующей операции ввода. 

Для ввода строки предназначена функция {\color{red}\verb*|gets()|, НО применять ее в программе не следует}, так как функция не производит никакой проверки длины строки, что может привести к переполнению буфера.

Лучше получать строку посимвольно с помощью функции \verb*|getchar()| или воспользоваться функцией \verb|fgets()|.

\emph{Строки} в языке Си представляют собой последовательность (\emph{массив}) \emph{символов}, последним элементом которого является \emph{нулевой символ} (\verb*|'\0|). 

Пример указателя
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
char *p = NULL;
\end{lstlisting}

То, что переменная \verb|p| является указателем, говорит символ \verb*|*| перед ее именем при объявлении. \emph{Значением указателя} является \emph{адрес данных} в \emph{памяти} компьютера. Указатель, которому присвоено значение \verb|NULL|, называется \emph{нулевым указателем}. Такой указатель ни на что не указывает, пока ему не будет присвоен адрес.

Размер массива символов и длина строка -- это разные вещи. Размер массива -- это общее количество символов. которое может хранить массив. Длина строки -- это количество символом внутри символьного массива до первого нулевого символа.
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
char buf[256] = "abc";  // массив символов
printf("%s\n", buf);  // abc
printf("%d\n", (int)sizeof(buf));  // 256
printf("%d\n", (int)strlen(buf));  // 3
\end{lstlisting}

Здесь \verb*|(int)sizeof(buf)| приводит результат вычисления \verb|sizeof(buf)| к целочисленному типу.

Функция \verb*|getchar()| позволяет получить символ только после нажатия клавиши \verb|<Enter>|. Если необходимо получить символ сразу после нажатия клавиши на клавиатуре, то можно воспользоваться функциями \verb*|_getche()| и \verb|_getch()|.

Функция \verb*|_getche()| возвращает код символа и выводит его на экран. При нажатии клавиши функция \verb|_getch()| возвращает код символа, но сам символ на экран не выводится. Это обстоятельство позволяет использовать функцию \verb*|_getch()| для получения конфиденциальных данных.

\subsubsection{Получение данных из командной строки}

Передать данные можно в командной строке после названия файла. Для получения данных в программе используется следующий формат функции \verb|main()|
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
int main(int argc, char *argv[]) {
    // Инструкции
    return 0;
}
\end{lstlisting}

Параметр \verb|argc| -- \emph{количество аргументов}, переданных в комадной строке. Следует учитывать, что первым аргументом является название исполняемого файла, поэтому значение параметра \verb*|argc| не может быть меньше единицы. Через второй параметр \verb*|argv| доступны \emph{все аргументы в виде строки} (тип \verb|char *|). Квадратные скобки после названия второго параметра означают, что доступен массив строк.

Чтобы окно программы сразу не закрывалось следует использовать функцию \verb|getchar()|
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
#include <stdio.h>
#include <stdlib.h>

int main(void) {
    printf("Process ...\n");
    printf("Press key\n");
    fflush(stdout);  // сбросить буфер вывода в консоль
    fflush(stdin);  // очистить буфер ввода
    getchar();  // приостанавливает закрытие окна программы
    return 0;
}
\end{lstlisting}

\subsubsection{Преждевременное завершение программы}

Для того чтобы прервать выполнение программы дострочно можно использовать функцию \verb*|exit()|. В качестве параметра функция принимает число, которое является \emph{статусом завершения}. Число 0 означает нормальное завершение программы, а любое другое число -- некорректное завершение. Эти числа передаются операционной системе.

Вместо чисел можно использовать макроопределения \verb|EXIT_SUCCESS| (нормальное завершение) и \verb*|EXIT_FAILURE| (аварийное завершение). Пример
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
exit(EXIT_FAILURE);  // То же что exit(1);
\end{lstlisting}



\section{Переменные и типы данных}

\emph{Переменные} -- это участки памяти, используемые программой для хранения данных. Прежде чем использовать переменную, ее необходимо предварительно \emph{объявить} глобально (вне функции) или локально (внутри функции). В большинстве случаев \emph{объявление переменной} является сразу и ее \emph{определением}.

При использовании старых компиляторов все локальные переменные должны быть объявлены в самом начале функции.

Каждая переменная должна иметь уникальное имя. Регистр бука имеет значение.

В языке Си доступны следующие элементарные типы данных:
\begin{itemize}
	\item \verb*|_Bool| -- логический тип данных. Может содержать значения <<Истина>> (соответствует числу~1) или <<Ложь>> (соответсвует числу 0)
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
_Bool is_int = 1;
printf("%d\n", is_int);  // 1
printf("%d\n", !is_int);  // 0
\end{lstlisting}

В языке Си нет ключевых слов \verb|true| и \verb|false|. Вместо них используеются числа 1 и 0 соответственно. Любое число, отличное от нуля, ялвяется истиной, а число, равно нулю, -- ложью. Если требуется объявлять логические переменные так же как в языке C++, можно подключить заголовочный файл \verb|stdbool.h|, в котором определены макросы \verb*|bool|, \verb*|true| и \verb|false|.

\item \verb*|char| -- код символа. Занимает 1 байт. Пример:
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
char ch = 'w';
printf("%c\n", ch);  // выводим символ w
printf("%d\n", ch);  // выводим код символа
printf("%d\n", (int)sizeof(char));  // размер в байтах
\end{lstlisting}

\item \verb|int| -- целое число со знаком.

\item \verb*|float| -- вещественное число. Занимает 4 байта.

\item \verb*|double| -- вещественное чило двойной точности. Занимает 8 байт.

\item \verb|void| -- означает отсутствие типа. Используется в основном для того, чтобы указать, что функция \emph{не возвращает никакого значения} или \emph{не принимает параметров}, а также для \emph{передачи} в функцию \emph{данных произвольного типа}.
\end{itemize}

Перед элементарным типом данных могут быть указаны следующие \emph{модификаторы} или их комбинация:
\begin{itemize}
	\item \verb*|signed| -- указывает, что \emph{символьный} или \emph{целочисленный типы} могут содержать отрицательные значения. Тип \verb*|signed int| (или просто \verb|signed|) соответствует типу \verb*|int|.
	
	\item \verb|unsigned| -- указывает, что \emph{символьный} или \emph{целочисленный типы} \underline{не могут} содержать \emph{отрицательные} значения.
	
	\item \verb|short| -- может быть указан перед целочисленным типом. Занимает 2 байта.
	
	\item \verb*|long| -- может быть указан перед целочисленным типом и типом \verb|double|.
\end{itemize}

При использовании модификаторов тип \verb|int| подразумевается по умолчанию, поэтому тип \verb*|int| можно не указывать.

Если переменная может изменять свое значение извне, то перед модификатором указывается ключевое слово \verb|volatile|. Это ключевое слово предотвращает проведение оптимизации программы, при котором предполагается, что значение переменной может быть изменено только в программе.

Вместо указания конкретного целочисленного типа можно воспользоваться макроопределениями \verb*|__int8|, \verb|__int16|, \verb*|__int32| и \verb|__int64|. В заголовочном файле \verb*|stdint.h| объявлены знаковые типы фиксированной длины \verb|int8_t|, \verb*|int16_t|, \verb|int32_t| и \verb*|int64_t|, а также беззнаковые \verb|unit8_t|, \verb*|unit16_t|, \verb|unit32_t| и \verb*|uint64_t|.

После \emph{объявления переменной} под нее \emph{выделяется} определенная \emph{память}, размер которой зависит от используемого типа данных и разрядности операционной системы \cite[\strbook{99}]{prokhorenok-prog-c:2020}. 

Оператор \verb*|sizeof|, например в \verb|(int)sizeof(x)| возвращает значение типа \verb|size_t|. При объявлении переменной ей можно сразу присвоить начальное значение, указав его после опреатора \verb*|=|. Переменная становится видимой сразу после объявления, поэтому на одной строке с объявлением (после запятой) эту переменную уже можно использовать для инициализации других переменных.

\emph{Локальные} (объявленные внутри функции) переменные инициализируются \emph{при каждом вызове функции}, а \emph{статические} (сохраняющие свое значение между вызовами) \emph{локальные переменные} -- один раз при первом вызове \cite[\strbook{100}]{prokhorenok-prog-c:2020}.

Оператор \verb*|typedef| позволяет создать псевдоним для существующего типа данных. В дальнейшем псевдоним можно указывать при объявлении переменной. 

Оператор имеет следующий формат
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
typedef long int lint;
lint x = 5L, y = 10L;
\end{lstlisting}

После создания псевдонима его имя можно использовать при создании другого псевдонима. Псевдонимы предназначены для создания машинно-независимых программ. Например тип данных \verb|size_t| является пседонимом, а не новым типом.

Константны -- это участки памяти, значения в которых не должны изменяться во время работы программы.

\subsection{Спецификаторы хранения}

Перед модификатором и типом могут быть указаны следующие \emph{спецификаторы хранения} \cite[\strbook{104}]{prokhorenok-prog-c:2020}:
\begin{itemize}
	\item \verb*|auto| -- локальная переменная создаетчя при входе в блок и удаляется при выходе из блока. Так как локальные переменные по умолчанию \emph{автоматические}, ключевое слово \verb|auto| в языке Си практически не используется.
	
	\item \verb*|register| -- является подсказкой компилятору, что переменная будет использоваться \emph{интенсивно}. Для ускорения досутпа значения такой переменной сохраняется в \emph{регистрах процессора}. Компилятор \emph{может проигнорировать} это объявление и сохранить значение \emph{в памяти}. Ключевое слово может использоваться при объявлении переменной внутри блока или в параметрах функции. К глобальным переменным не применяется.
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
register int x = 10;
\end{lstlisting}
    \item \verb|extern| -- сообщает компилятору, что переменная определена \underline{в другом месте}, например, в другом файле. Ключевое слово лишь \emph{объявляет} переменную, а \emph{не определяет} ее. Таким образом, \emph{память} под переменную \emph{повторно не выделяется}. Если при объявлении переменной производится инициализация переменной, то \emph{объявление}  становится \emph{определением переменной}
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
#include <stdio.h>

int main(void) {
    extern int x;        // Определена в другом месте
    printf("%d\n", x);  // 10
}

// Другое место
int x = 10;  // Определение переменной x
\end{lstlisting}
    \item \verb*|static| -- если ключевое слово указано перед локальной переменной, то \emph{значение будет сохраняться между вызовами функции}. \emph{Инициализация} статических локальных переменных производится только при первом вызове функции. При последующих вызовах используется сохраненное ранее значение.
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
#include <stdio.h>

int func(void);  // объявление функции

int main(void) {
    printf("%d\n", func()); // 1
    printf("%d\n", func()); // 2
    printf("%d\n", func()); // 3
    
    return 0;
}

int func(void) {
	// статические локальные переменные инициализируются только один раз
	// при первом вызове функции
    static int x = 0;  
    ++x;
    return x;
}
\end{lstlisting}

Пори каждом вызове функции \verb*|func()| значение статической переменной \verb|x| будет увеличиватся на единицу. Если убрать ключевое слово \verb*|static|, то при каждом вызове будет выводиться число 1, так как \emph{автоматические локальные переменные} инициализируются при входе в функцию и уничтожаются при выходе из нее.

Если ключевое слово \verb|static| указано перед \emph{глобальной} переменной, то ее значение будет \emph{видимо только в пределах файла}.
\end{itemize}

В Python поведение статической локальной переменной можно симитировать, например, с помощью ключевого слова \verb*|global|
\begin{lstlisting}[
style = ironpython,
numbers = none
]
x = 0

def func() -> int:
    global x
    x += 1
    return x

def main():
	print(func())  # 1
	print(func())  # 2
	print(func())  # 3
	
if __name__ == "__main__":
    main()
\end{lstlisting}

Очень важно учитывать, что переменная, объявленная \emph{внтури блока}, \emph{видна} \emph{только в пределах блока} (внутри фигурных скобок) \cite[\strbook{106}]{prokhorenok-prog-c:2020}.

\subsection{Массивы}

Массив -- это нумерованный набор переменных одного типа. Объем памяти массива (в байтах), занимаемый массивом, определяется так
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
<Объем памяти> = sizeof(<Тип>) * <Количество элементов>
\end{lstlisting}

Объявление массива выглядит следующим образом
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
<Тип> <Переменная>[<Количество элементов>];
// Пример
long arr[3] = {10, 20, 30};
\end{lstlisting}

После закрывающей фигурной скобки обязательно указывается точка с запятой. Количество значений внутри фигруных скобок может быть меньше количества элементов массива.

В рассмотренном примере первому элементу массива присваивается значение 10, второму -- значение 20, а третьему элементу будет присвоено значение 0.

Если при объявлении массива указыается начальные значения, то количество элементов внутри квадратных скобок можно не указывать
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
long arr[] = {10, 20, 30};

for (int i = 0; i < 3; ++i) {
    printf("arr[i=%d] = %ld", i, arr[i]);
}
\end{lstlisting}

Если при объявлении массива начальные значения не указаны, то:
\begin{itemize}
	\item элементам глобальных массивов автоматически присваивается значение 0;
	
	\item элементы локальных массивов будут содержать произвольные значения, так называемый <<мусор>>.
\end{itemize}

NB: следует учитывать, что \emph{проверка выхода} указанного \emph{индекса} за пределы диапазона на этапе компиляции \emph{\color{red}не производится}. Таким образом, можно перезаписать значение в смежной \emph{ячейке памяти} и тем самым нарушить работоспособность программы или \emph{даже повредить операционную систему} \cite[\strbook{108}]{prokhorenok-prog-c:2020}.

Все элементы массива располагаются в \emph{смежных ячейках памяти}. После определения массива выделяется необходимый размер пмяти, а в \emph{переменной} сохраняется \emph{адрес первого элемента} массива.

\subsubsection{Строка}

Строка является массивом символов, последний элемент которого содержит нулевой символ (\verb*|'\0'|). Такие строки часто называют \emph{C-строками}.

Присваивать строку в двойных кавычках можно только при инициализации. Объявить массив строк можно следующим образом
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
char valid_solver_names[][10] = {"gurobi", "cplex", "scip"};

// обойти массив строк
for (int i = 0; i < 3; ++i) {
    printf("%s", valid_solver_names[i]);
}
\end{lstlisting}

\subsubsection{Указатели}

\emph{Указатель} -- это \emph{переменная}, которая предназначена для \emph{хранения адреса}. В языке Си указатели часто используются в следующих случаях:
\begin{itemize}
	\item для управления динамической памятью,
	
	\item чтобы иметь возможность изменить значение переменной внутри функции,
	
	\item для эффективной работы с массивами и др.
\end{itemize}

Объявлнеие укзателя имеет следующий формат:
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
<Тип> *<Переменная>;
// Пример
int *p = NULL;
\end{lstlisting}

Для того чтобы \emph{указателю} \underline{\itshape присвоить} \emph{адрес переменной}, необходимо при присваивании значения перед названием переменной добавить оператор \verb*|&|. Типы данных переменной и указателя должны совпадать. Это нужно, чтобы при адресной арифметике был известен размер данных
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
int *p = NULL, x = 10;
p = &x;  // присваивание указателю адреса переменной
printf("%d\n", *p); // чтение значения по адресу; 10

*p = *p + 20;   // изменение значения
printf("%d\n", p*);  // ; 30
\end{lstlisting}

Указатель, которому присвоено значение \verb|NULL| (это макрос), называется \emph{нулевым указателем}.

\emph{Глобальные} и \emph{статические локальные указатели} автоматические получают значение 0. Однако \emph{указатели}, которые объявлены в \emph{локальной области видимости}, будут иметь \emph{\color{red}произвольные значения}. Если попытаться записать какое-либо значение через такой указатель, то можно повредить операционную систему. Поэтому, согласно соглашению, указатели, которые ни на что не указывают, должны иметь значение \verb*|NULL| \cite[\strbook{113}]{prokhorenok-prog-c:2020}.

При инициализации указателя ему можно присвоить не только числовое значение, но и строку. Пример
\begin{lstlisting}[
style = c_cpp,
numbers = none	
]
const char *str = "String";
printf("%s\n", str);
\end{lstlisting}

Указатели можно сохранять в массиве. При объявлении \emph{массива указателей} используется следующий синтаксис
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
<Тип> *<Переменная>[<Количество элементов>];
\end{lstlisting}

Пример использования массива указателей
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
int *p[3];  // Массив указателей из 3 элементов
int x = 10, y = 20, z = 30;

p[0] = &x;  // указателю присваивается адрес переменной x
p[1] = &y;
p[2] = &z;

for (int i = 0; i < 3; i++) {
    printf("p[%d] = %d\n", i, *p[i]);
}
\end{lstlisting}

Объявление массива указателей на строки выглядит так
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
const char *str[] = {"String1", "String2", "String3"};
printf("%s\n|, str[0]);  // String1
\end{lstlisting}

\emph{Указатели} очень часто используются \emph{для обращения к элементам массива}, так как \emph{адерсная арифметика} выполняется \emph{эффективнее}, чем доступ по индексу \cite[\strbook{114}]{prokhorenok-prog-c:2020}
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
#include <stdio.h>
#define ARR_SIZE 3  // препроцессорная константна

int main(void) {
    int *p = NULL, arr[ARR_SIZE] = {10, 20, 30};
    p = arr;  // присвоить указателю адрес первого элемента массива arr
    
    for (int i = 0; i < ARR_SIZE; ++i) {
        printf("arr[%d] = %d\n", i, *p);
        ++p;  // переместить указатель на следующий элемент
    }
    p = arr;  // восстановить положение указателя
}
\end{lstlisting}

В строке \verb|p = arr;| \emph{указателю} присваивается \emph{адрес} первого элемента массива. Перед названием массива отсутствует оператор \verb|&|, так как \emph{название переменной} содержит \emph{адрес первого элемента} массива
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
p = &arr[0];  // то же что p = arr;
\end{lstlisting}

В строке \verb*|++p;| увеличивается \emph{значение указателя} на единицу. Здесь изменяется \emph{адрес}, а не значение элемента массива. При увеличении значения указателя используются правила \emph{адресной арифметики}, а не правила обычной.

Увеличение значения указателя на единицу означает, что значение будет \emph{увеличено на \underline{размер типа}}. Например, если тип \verb*|int| занимает 4 байта, то при увеличении значения на единицу указатель вместо адреса \verb|0x0012FF30| будет содержать адрес \verb*|0x0012FF34|. Значение увеличилось на 4, а не 1.

Вместо двух инструкций внутри цикла можно использовать одну
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
printf("%d\n", *p++);  // то же что *(p++)
\end{lstlisting}

Выражение \verb|p++| возвращает \emph{текущей адрес}, а затем увеличивает его на единицу. Символ \verb*|*| позволяет получить \emph{доступ к значению элемента по указанному адресу}.

Получить доступ к элементу массива можно несколькими спосбами
\begin{lstlisting}[
style = c_cpp,
numbers = none	
]
int arr[3] = {10, 20, 30};

printf("%d\n", arr[1]); // 20
printf("%d\n", *(arr + 1));  // 20
printf("%d\n", *(1 + arr));  // 20
printf("%d\n", 1[arr]);  // 20
\end{lstlisting}

С указателем можно выполнять следующие арифметические и логические опреации:
\begin{itemize}
	\item прибавлять целое число; число умножается на размер базового типа указателя, а затем прибавляется к адресу,
	
	\item вычитать целое число,
	
	\item вычитать один указатель из другого. Это позволяет получить количество элементов базового типа между двумя указателями,
	
	\item сравнивать указатели между собой.
\end{itemize}

При использовании ключевого слова \verb*|const| применительно к указателям важно учитывать местоположение ключевого слова \verb|const| \cite[\strbook{116}]{prokhorenok-prog-c:2020}. 

Например
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
// константный указатель
// const действует на значение
const char *str = "String";
char const *str = "String";
\end{lstlisting}
это одно и то же и означает, что значение, на которое ссылается указатель изменять нельзя, но указателю можно присвоить другой адрес.

В этом случае
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
char * const p = "String";  // const действует на адрес
\end{lstlisting}
значение, на которое ссылается указатель изменить можно, но указателю нельзя присвоить другой адрес.

А в этом случае
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
const char * const p = "String";
\end{lstlisting}
запрещается изменение значения, на которое ссылается указатель и присвоение другого адреса.

Указатели часто используются при передаче параметров в функцию. По умолчанию в функцию передается \emph{копия значения переменной}. Если мы в этом случае изменим значение внутри функции, то это действие не затронет значения внешней переменной.

Для того чтобы иметь возможность \emph{изменять} значение внешней переменной, параметр функции объявляют \emph{как указатель}, а при вызове передают адрес переменной.

Передать параметры в функцию можно \emph{по значению} (применяется по умолчанию). При этом создается \emph{копия} значения, и все операции выполняются с копией. Так как локальные переменные видны только внутри тела функции, после завершения выполнения функции копия удаляется. 

А можно передать \emph{по ссылке}. Внутри функции адрес переменной присваивается указателю. Использую операцию \emph{разыменования указателя}, можно \emph{изменить} значение \emph{самой переменной}, а не значение копии. 

\subsubsection{Динамичекое выделение памяти}

При объявлении переменной необходимо указать тип данных, а для массива дополнительно задать точное количество элементов. На основе этой информации при запуске программы автоматически выделяется необходимый объем памяти. После завершения программы память автоматически освобождается. Иными словами, объем памяти необходимо знать до выполнения программы. Во время выполнения программы создать новую переменную или увеличить размер существующего массива нельзя.

Для того чтобы произвести  увеличение массива во время выполнения программы, необходимо выделить достаточный объем \emph{динамической памяти}, перенести существующие элементы, а лишь затем добавить новые элементы. После завершения работы с памятью необходимо самим возвратить память операционной системе. Если этого не сделать, то участок памяти станет недоступным для дальнейшего испольования. Подобные ситуации приводят к утечке памяти.

Для выделения динамической памяти в языке Си предназначена функция \verb*|malloc()|. Функция \verb|malloc()| принимает в качестве параметра размер памяти в байтах и возвращает \emph{указатель}, имеющий тип \verb|void *|. В языке Си указатель типа \verb|void *| неявно приводится к другому типу, поэтому использовать явное приведение не нужно (в языке C++ нужно обязательно выполнять явное приведение).

\begin{lstlisting}[
style = c_cpp,
numbers = none
]
const unsigned ARR_SIZE = 3;
int *p = malloc(ARR_SIZE * sizeof(int));
\end{lstlisting}

Если память выделить не удалось, то функция возвращает \emph{нулевой указатель}. Все элементы будут иметь произвольное значение, <<мусор>>.

Освободить ранее выделенную динамическую память позволяет функция \verb*|free()|. Функция \verb|free()| принимает в качестве параметра указатель на ранее выделенную память и освобождает ее.

Пример использования функций \verb*|malloc()| и \verb*|free()|
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
#include <stdio.h>
#include <stdlib.h>
#inlucde <locale.h>

int main(void) {
    const unsigned ARR_SIZE = 10;
    int *p = malloc(ARR_SIZE * sizeof(int));
    
    if (!p) {
        puts("Oops ...");
        exit(1);
    }
    
    for (int i = 0; i < ARR_SIZE; ++i) {
        p[i] = i + 1;
    }
    
    for (int i = 0; i < ARR_SIZE; ++i) {
        printf("p[%d] = %d", i, p[]);
    }
    
    free(p);  // NB
    p = NULL;  // NB
}
\end{lstlisting}

Вместо функции \verb*|malloc()| можно воспользоваться функцией \verb|alloc()|. Если память выделить не удалось, то функция возвращает нулевой указатель. Все элементы будут иметь значение 0.

Пример динамического выделения памяти под двумерный массив
\begin{lstlisting}[
style = c_cpp,
numbers = none	
]
#include <stdio.h>
#include <stdlib.h>

int main(void) {
    const unsigned int ROWS = 2;
    const unsigned int COLUMNS = 4;
    int i = 0, j = 0;
    
    int **p = calloc(ROWS, sizeof(int*));
    if (!p) exist(1);
    
    for (i = 0; i < ROWS; ++i) {
        p[i] = calloc(COLUMNS, sizeof(int));
        if (!p[i]) exit(1);
    }
    
    int n = 1;
    for (i = 0; i < ROWS; ++i) {
        for (j = 0; j < COLUMNS; ++j) {
            p[i][j] = n++;
            // *(*(p + i) + j) = n++;
        }
    }
    
    for (i = 0; i < ROWS; ++i) {
        for (j = 0; j < COLUMNS; ++j) {
            printf("%3d", p[i][j]);
            // printf("%3d", *(*(p + i) + j));
        }
        printf("\n");
    }
    
    for (int i = 0; i < ROWS; ++i) {
        free(p[i]);
        freep(p);
        p = NULL;
    }
}
\end{lstlisting}

При возвращении памяти вначале освобождается память, выделенная ранее под строки, а лишь затем освобождается память, выделенная ранее под массив указателей.

Строки в памяти могут быть расположены в разных местах, что не позволяет эффективно получать доступ к элементам двумерного массива. Для того чтобы доступ к элементам сделать максимально быстрым, можно представить двумерный массив в виде одномерного массива.
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
#include <stdio.h>
#include <stdlib.h>

int main(void) {
    const unsigned ROWS = 2;
    const unsigned COLUMNS = 4;
    unisgned i = 0, j = 0;
    int *p = calloc(ROWS * COLUMNS, sizeof(int));
    if (!p) exit(1);
    
    int n = 1;
    for (i = 0; i < ROWS; ++i) {
        for (j = 0; j < COLUMNS; ++j) {
            *(p + i * COLUMNS + j) = n++;
        }
    }
    
    for (i = 0; i < ROWS; ++i) {
        for (j = 0; j < COLUMNS; ++j) {
            printf("%3d", *(p + i * COLUMNS + j));
        }
        printf("\n");
    }
    free(p);  // осводбодить память
    p = NULL;  // обнулить указатель
}
\end{lstlisting}

В данном случае все элементы расположены в смежных ячейках, и можно получить доступ к элементам с помощью указателя и адресной арифметики. 

Функция \verb|realloc()| выполняет перераспределение памяти. Функция выделит динамическую память длиной \verb*|newSize|, скопирует в нее элементы из старой области памяти, освободит старую память и вернет указатель на новую область памяти. Новые элементы будут иметь произвольные значения, так называемый <<мусор>>. Если новая длина меньше старой, то лишние элементы будут удалены. Если память не может быть выделена, то функцию вернет \emph{нулевой указатель}, при этом старая область памяти не изменяется (в этом случае возможны утечки памяти, если значение присваивается прежнему указателю).

Пример
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
#include <stdio.h>
#include <stdlib.h>

int main(void) {
    unsigned arr_size = 5;
    int *p = malloc(arr_size * sizeof(int));
    if (!p) exit(1);
    
    for (int i = 0; i < arr_size; i++) {
        *(p + i) = i + 1;  // p[i] = i + 1;
    }
    
    arr_size += 2;
    p = realloc(p, arr_size * sizeof(int));
    // Здесь возможна утечка памяти, если realloc() вернет NULL
    if (!p) exit(1);
    
    *(p + 3) = 55;  // p[3] = 55;
    *(p + 4) = 66;  // p[4] = 66;
    
    for (int i = 0; i < arr_size; i++) {
        printf("%d", *(p + i));
    }
    
    free(p);
    p = NULL;
}
\end{lstlisting}

\subsubsection{Структуры}

\emph{Структура} -- это совокупность переменных (называемых элементами, или полями), объединенных под одним именем. Объявление структуры выглядит следующим образом:
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
struct [<Название структуры>] {
    <Тип данных> <Название поля 1>;
    <Тип данных> <Название поля 2>;
    ...
} [<Объявление переменных через запятую>];
\end{lstlisting}

Допустимо не задавать название структуры, если после закрывающей фигурной скобки указано объяление переменной. \emph{Точка с запятой} в конце объявления структуры является \emph{обязательной}.

Объявление структуры только описывает \emph{новый тип данных}, а не определяет переменную, поэтому память под нее не выделяется. Для того чтобы объявить переменную, ее название указывается после закрывающей фигурной скобки при объвялении структруры или отдельно с помощью названия структуры в качестве типа данных:
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
struct <Название структуры> <Названия переменных через запятую>;
\end{lstlisting}

Одновременно с объявлением переменной можно выполнить инициализацию полей структуры, указав значения внутри фигурных скобок:
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
struct Point point1 = {10, 20};
\end{lstlisting}

Можно указать имя поля
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
struct Point point2 = {.x = 100, .y = 200};
\end{lstlisting}

После объявления переменной выделяется необходимый размер памяти. Для получения размера структуры внутри программы следует использовать оператор \verb*|sizeof|:
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
<Размер> = sizeof(<Переменная>);
<Размер> = sizeof(<struct <>>);
\end{lstlisting}

Одну структру можно присвоить другой с помощью оператора \verb|=|. В этом случае копируются значения всех полей структуры.

Структуры можно вкладывать. При обращении к полю вложенной структуры дополнительно указывается название структуры родителя
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
#incude <stdio.h>

struct Point {
    int x;
    int y;
};

struct Rectangle {
    struct Point top_left;
    struct Point bottom_right;
};

int main(void) {
    struct Rectangle rec = {
        .top_left = {
            .x = 100,
            .y = 200,
        },
        .bottom_right = {
            .x = -1,
            .y = -2,
        }
    };
    
    printf("top left x: %d", rec.top_left.x);
    printf("bottom right y: %d", red.bottom_right.y);
}
\end{lstlisting}

Адрес структуры можно сохранить в указателе. Для получения адреса структуры используется оператора \verb*|&|, а для доступа к полю структуры вместо точки применяется оператор \verb|->|
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
#include <stdio.h>

struct Point {
    int x;
    int y;
} point1;

int main(void) {
    struct Point *p = &point1;
    
    p->x = 10;
    p->y = 20;
    
    printf("%d\n", p->x);
    printf("%d\n", (*p).y);
}
\end{lstlisting}

\subsubsection{Битовые поля}

\emph{Битовые поля} предоставляют доступ к отдельным битам, позволяя тем самым хранить в одной переменной несколько значений, занимающих указанное количество битов. Один бит может содержать только числа 0 или 1.

Битовые поля объявляются только с типом \verb*|int|. В одной структуре можно использовать одновременно битовые поля и обычные поля. Название битового поля можно не указывать. Кроме того, если длина поля составляет 1 бит, то дополнительно следует указать ключевое слово \verb|unsigned|
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
struct Status {
    unsigned int flag1:1;
    unsigned int flag2:1;
    unsigned int flag3:1;
} status = {0, 1, 1};

printf("%d\n", status.flag1);  // 0
status.flag2 = 1;
printf("%d\n", (int)sizeof(struct Status));
\end{lstlisting}

\subsubsection{Объединения}

\emph{Объединение} -- это область памяти, используемая для хранения данных \emph{разных} типов. В один момент времени в этой области могут храниться данные только одного типа. Размер будет соответствовать размеру более сложного типа данных. Например, если внутри объединения определены переменные, имеющие типы \verb*|int|, \verb|float| и \verb*|double|, то размер объединения будет соответствовать размеру типа \verb|double|. Точка с запятой в конце объявления обязательна. Объединение только описывает новый тип данных, а не определяет переменную, поэтому память под нее не выделяется.

\subsubsection{Перечисления}

\emph{Перечисление} -- это совокупность целочисленных констант, описывающих все допустимые значения переменной. Точка с запятой в конце объявления явлюятся обязательной.

Пример
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
enum Color {
    RED,  // 0
    BLUE,  // 1
    GREEN,  // 2
    BLACK  // 3
};
\end{lstlisting}

Константам \verb*|RED|, \verb|BLUE| ... автоматически присваиваются целочисленные значения, начиная с нуля.

При объявлении перечисления константе можно присвоить другое значение. В этом случае последующая константа будет иметь значение на единицу больше того, другого значения. Пример
\begin{lstlisting}[
style = c_cpp,
numbers = none
]
enum Color {
    RED = 3,
    BLUE,  // 4
    GREEN = 7,
    BLACK  // 8
} color1;
\end{lstlisting}








% Источники в "Газовой промышленности" нумеруются по мере упоминания 
\begin{thebibliography}{99}\addcontentsline{toc}{section}{Список литературы}
	
	\bibitem{podbelskiy-prog-c:2005}{ \emph{Подбельский В.В.}, \emph{Фомин С.С.} Прграммирование на языке Си, 2005. -- 600 с. }
	
		\bibitem{prokhorenok-prog-c:2020}{ \emph{Прохоренок Н.А.} Язык С. Самое необходимое. -- СПб.: БХВ-Петербург, 2020. -- 480 с. }
\end{thebibliography}

%\listoffigures\addcontentsline{toc}{section}{Список иллюстраций}

\lstlistoflistings\addcontentsline{toc}{section}{Список листингов}

\end{document}
